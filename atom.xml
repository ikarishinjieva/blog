<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tac say]]></title>
  <link href="http://ikarishinjieva.github.com/blog/atom.xml" rel="self"/>
  <link href="http://ikarishinjieva.github.com/blog/"/>
  <updated>2013-12-19T22:41:11+08:00</updated>
  <id>http://ikarishinjieva.github.com/blog/</id>
  <author>
    <name><![CDATA[Tac Huang (ikari_shinji@github)]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[对于PaxosLease的个人理解 1]]></title>
    <link href="http://ikarishinjieva.github.com/blog/blog/2013/12/19/paxos-lease/"/>
    <updated>2013-12-19T20:19:00+08:00</updated>
    <id>http://ikarishinjieva.github.com/blog/blog/2013/12/19/paxos-lease</id>
    <content type="html"><![CDATA[<p>Paxos是分布式解决数据一致性的算法，而PaxosLease是Paxos中的一个子集，用于在集群中选择出一个节点作为master</p>

<p>最近因为项目需要，实现了一下PaxosLease，代码放在<a href="https://github.com/ikarishinjieva/PaxosLease-go">Github</a>上</p>

<p>计划用两篇blog，分别记录下自己对PaxosLease的理解，以及对PaxosLease应用时的一些变化。<br/>这篇是我对PaxosLease的个人理解，如有任何bug/改进的建议，欢迎comment</p>

<hr />

<p>首先，定义一下问题场景：有N个节点组成一个集群，需要从其中选出一个master。（其中可能遇到节点间传输的信息延迟/丢失，节点离线，网络脑裂等等状况）</p>

<p>在这个定义中，先要解决如何定义“选出一个master”，有以下两种可能</p>

<ol>
<li>仅有master节点知道自己是master，其他节点只知道自己不是master，而不知道谁是master</li>
<li>所有在线节点都知道谁是master，离线节点要等待下次选举</li>
<li>所有节点都知道谁是master，离线节点上线时要学习谁是master</li>
</ol>


<p>PaxosLease选择的是第一种方式（在此只讨论没有Learner的情况，有Learner的情况可以实现另外两种情况），这种方式满足现在的项目需要</p>

<p>这一个部分的结论：在以上的定义下，PaxosLease需要满足一个<em>不定式</em>：在同一时间，集群内至多有一个节点认为自己是master</p>

<hr />

<p>要在多个节点达成一致，最通常的想法是二段提交（2-phase commit，2PC），经典2PC步骤是：</p>

<ol>
<li>某节点A向其他所有节点发起PrepareRequest（准备请求）</li>
<li>某节点B收到节点A的PrepareRequest，经过状态检查，将自己的状态置为PrepareReady（表示可以接受A的PrepareRequest）<br/>并向A发送PrepareResponse（准备请求的回复）</li>
<li>A收到其他节点发来的PrepareResponse，当满足<em>某个条件</em>时，A认为集群整体同意了他得PrepareRequest。<br/>于是A向其他所有节点发出CommitRequest（提交请求）</li>
<li>节点B收到A的CommitRequest，且检查到<em>当前状态是为A准备的状态</em>，则向A发送CommitResponse（提交回复）</li>
<li>A收到其他节点发来的CommitResponse，当满足<em>某个条件</em>时，A认为集群已经完成了提交</li>
</ol>


<p><img src="http://ikarishinjieva.github.com/blog/images/2013-12-19-paxos-lease-1.png"></p>

<p>但经典的2PC没有以下解决的问题：</p>

<ol>
<li>如何解决master突然离线，比如网络故障</li>
<li>如何面对选举过程中通信可能发生的延迟和中断</li>
<li>如何处理网络脑裂</li>
<li>是否会发生动态死锁</li>
</ol>


<hr />

<p>这一部分将解决master突然离线的问题。根据<em>不变式</em>，除了master本身，没有节点知道谁是master。在这种情况下，如果不做点什么，集群就不会有master了</p>

<p>解决方案是使用租约，即谁持有租约谁是master，那么在租约过期后，集群可以重新选举出master</p>

<p>这样在master突然离线时，其他节点<em>等到租约过期</em>，即可重新选举出新的master。此时就master租约肯定也过期了，满足<em>不定式</em></p>

<p>以上<em>等到租约过期</em>的做法有一个前提，即所有节点都知道统一的租约时长 （此处是时长，而不是过期时间。PaxosLease并不要求各个节点时钟同步，因此必须使用时长）</p>

<hr />

<p>这一部分将解决选举过程中通信可能发生延迟。</p>

<p>发生延迟意味着A-B已经进入了下一轮投票，C可能才完成上一轮投票，C的反馈可能影响到这一轮投票结果。</p>

<p>此处PaxosLease引入了投票ID（PaxosLease称ProposeId，后面会统一名称的）的概念，投票ID对于某一节点A，在全局是单调递增的。常用的投票ID结构为&lt;投票轮数 | 重启计数 | 节点ID>（“|”为字符串拼接），这个ID可以被持久化存储，即新一轮投票或节点重启都会单调递增。</p>

<p>有了投票ID，那么节点可以只响应本轮的反馈，而不受其他轮的干扰。</p>

<hr />

<p>这一部分将解决选举过程中通信可能发生中断。</p>

<p>发生中断意味着选举可能被无限期拖延下去。很容易得出解决方案：设置超时时间。即在2PC每一个阶段都设置超时时间，若超时，则回退重新开始新一轮的2PC</p>

<hr />

<p>这一部分将解决网络脑裂的问题。比如有5个节点的集群，分割为[1,2]和[3,4,5]，那么在[1,2]子集群中不能选举出master，而在[3,4,5]子集群中必须要选举出master。若脑裂前master落在[1,2]，那么租约到期后，[1,2]不能选举出master</p>

<p>解决方案是：指定2PC步骤中的<em>某个条件</em>为“收到集群中超过一半的节点正反馈”。那么[3,4,5]子集群可能选出master，而[1,2]由于只有2个节点，小于ceil(5/2) = 3，没法选出master</p>

<hr />

<p>这一部分将讨论如何解决动态死锁</p>

<p>首先说明何为动态死锁，比如有4个节点的集群[1,2,3,4]，1和4同时请求自己为master，1的request发给2，而4的request发给3，没有任何一方获得多数派，于是进入新的一轮，以上状况重复出现，陷入死循环，没法选出master</p>

<p>观察这个问题的症结在于，2收到1的prepare request后，进入PrepareReady状态，将不再接受4发来的请求。这样[1,2]和[3,4]不断对撞，陷入死锁。</p>

<p>解决方案是PaxosLease引入了“不稳定”的PrepareReady，即2进入为1准备的PrepareReady状态后，如果收到4的PrepareRequest，且这个投票ID大于来自1的PrepareRequest的投票ID，则2转而进入为4准备的PrepareReady</p>

<p>可以看到投票ID代表了优先级，也就能理解之前要求<strong>某节点</strong>的投票ID单调递增的理由了</p>

<p>需要说明的是，上述做法只是大大降低动态死锁的概率，但仍然可能存在小概率的动态死锁，即两个节点1和4不断增大投票ID且在2和3进入Commit之前不断抢占2和3，形成竞争，可以引入随机的等待来规避这个小概率事件</p>

<hr />

<p>在此，将上面描述的名词对应到PaxosLease算法的术语上</p>

<ul>
<li>租约 = lease（租约）</li>
<li>投票 = propose (提案)</li>
<li>发出request的节点 = proposer</li>
<li>接受request，发出response的节点 = accepter</li>
<li>CommitRequest = ProposeRequest</li>
<li>CommitResponse = ProposeReponse</li>
<li>投票ID = ProposeID</li>
</ul>


<p>之后将使用术语</p>

<hr />

<p>以上，是出于个人理解，来理解PaxosLease的几个重要元素：</p>

<ol>
<li>lease</li>
<li>propose</li>
<li>ProposeId</li>
<li>两阶段的超时设置</li>
<li>多数派形成决议</li>
</ol>


<p>一些实现上的问题会在下一篇blog讨论</p>

<hr />

<p>再次讨论<em>不变式</em></p>

<p>在某一时刻，集群中最多存在一个Proposer，知道自己获得了租约。</p>

<p>此时，多数Accepter知道在<em>某一个时刻</em>前某个提案（AcceptedProposeId）是生效的。其他Proposer了解到多数Accepter都有AcceptedProposeId，则其不能获得租约。</p>

<p>这里说明一下上句中的<em>某一时刻</em>。借用参考[1]中的图</p>

<p><img src="http://ikarishinjieva.github.com/blog/images/2013-12-19-paxos-lease-2.png"></p>

<p>可以看到Proposer和Accepter间有时间差，即<em>某一个时刻</em>指的是当前Accepter定时器超时的时刻，但这并没有影响<em>不变式</em>成立。即在满足当前不变式时，<strong>不要求各个节点时钟同步</strong></p>

<hr />

<p>以上是我个人的理解，如有不妥，烦请看官comment</p>

<p>建议此时参看文末的参考文献和Keyspace源码。之后请期待下一篇：实现PaxosLease中的一些问题和解决</p>

<p>顺便吐个槽，我没有数学天赋和算法天赋，也实在没兴趣下苦工，实在不够进取。罪过罪过。</p>

<hr />

<h2>参考文献</h2>

<p>[1]<a href="http://dsdoc.net/paxoslease/index.html">【译】PaxosLease：实现租约的无盘Paxos算法</a></p>

<p>[2] <a href="https://github.com/scalien/keyspace/tree/master/src/Framework/PaxosLease">Keyspace源码</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于DEV测试的一些经验总结]]></title>
    <link href="http://ikarishinjieva.github.com/blog/blog/2013/12/09/test-framework-exp/"/>
    <updated>2013-12-09T20:05:00+08:00</updated>
    <id>http://ikarishinjieva.github.com/blog/blog/2013/12/09/test-framework-exp</id>
    <content type="html"><![CDATA[<p>已经是第三遍重写项目主代码了，这几天用主代码和测试框架互相补充。总结下经验值，以期升级</p>

<hr />

<p>关于测试框架，重写了几遍仍然保留下来的功重要能是：</p>

<ol>
<li><p>插桩代码，后面的功能也都依赖插桩。不在主代码中插桩，测试基本靠拜神；</p></li>
<li><p>条件池，根据条件池，代码才能沿着需要的分支进行；</p></li>
<li><p>签到点（checkpoint），代码要能根据测试要求停得下来，等待状态，之后跑得起来；</p></li>
<li><p>外缘测试。比起直接测试变量，还是分析log比较容易维护</p></li>
</ol>


<p>测试的难点是：</p>

<ol>
<li><p>资源回收。要连续跑测试，资源回收是说说容易的事。tcp server关了，listener停了，关闭的那些connection会不会瞬时占用临时端口；如果某一个connection正在申请二步锁，测试停止时远端锁失败，近端锁如果不释放会不会影响之后的测试；如果系统会自动重启tcp server，tcp server是在测试关闭操作之前停还是之后停还是停两次。想想头就大了。</p></li>
<li><p>想停都停不下来，万一断言失败，测试要能停下来。整个flow上都要处理停止中断，用“硬”中断很难掌握资源回收的状况；用“模拟”中断，所有等待/超时/重试的地方都要处理，逐级退栈。比起不测试的代码，主代码花在错误处理的代码量要大很多，但是值得。</p></li>
<li><p>测试界限把握不易。测粗了没作用，测细了耗时间而且波动大。插桩的深度，模拟中断的层级，这些都要拿好轻重。否则代码已腐败。</p></li>
</ol>


<p>每次跑测试，比起旁边坐个QA的测试，更步步惊心。QA一天才跑十几个case，自动的话2-3分钟就跑十几个简化的case，出错的概率要大很多。</p>

<p>最后反思一下，如果靠人肉测，&#8230;</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[对Memory Reordering Caught in the Act的学习 续 - 关于go的部分]]></title>
    <link href="http://ikarishinjieva.github.com/blog/blog/2013/11/11/study-memory-reorder-cont/"/>
    <updated>2013-11-11T20:44:00+08:00</updated>
    <id>http://ikarishinjieva.github.com/blog/blog/2013/11/11/study-memory-reorder-cont</id>
    <content type="html"><![CDATA[<p>这篇主要解决<a href="http://ikarishinjieva.github.io/blog/blog/2013/11/07/study-memory-reorder/">上一篇</a>遗留下来的问题，问题的简要描述请参看<a href="http://stackoverflow.com/questions/19901615/why-go-doesnt-show-memory-reordering">我发在SO上的帖子</a></p>

<p>主要的问题是用c++可以重现memory reordering，但go的程序没有重现</p>

<p>主要的结论是写go的时候我忘记设置GOMAXPROC，在目前这个go版本(1.2 rc2)下，不设置GOMAXPROC goroutine不会并发的，自然也没法设置memory reordering</p>

<p>此篇主要内容到此结束，以下是这两天的一些探索过程和技巧，觉得还是挺有意思的</p>

<hr />

<h4>go tool生成的汇编码和真实的汇编码是有很大差距的</h4>

<p>这个结论并不奇怪，但是差异的程度还是会影响诸如lock-free的代码的使用前提</p>

<p>对以下代码做对比</p>

<pre><code>x = 1
r1 = y
</code></pre>

<p>使用<code>go tool 6g -S xxx.go</code>反编译后的代码</p>

<pre><code>0246 (a.go:25) MOVQ    $1,x+0(SB)   //X=1
0247 (a.go:26) MOVQ    y+0(SB),BX
0248 (a.go:26) MOVQ    BX,r1+0(SB)  //r1=Y
</code></pre>

<p>而真实运行在cpu上的代码（<code>ndisasm -b 32 xxx</code>)为</p>

<pre><code>000013EB  C70425787F170001  mov dword [0x177f78],0x1     //X=1
         -000000
000013F6  48                dec eax
000013F7  8B1C25807F1700    mov ebx,[0x177f80]
000013FE  48                dec eax
000013FF  891C25687F1700    mov [0x177f68],ebx          //r1=Y
00001406  48                dec eax
</code></pre>

<p>可以看到在访问共享内存的前后多出了<code>dec eax</code>作为margin，这个原因不明，也没有找到相应的资料</p>

<p>但总的来说<code>ndisasm</code>产生的汇编代码更方便于对go行为的理解</p>

<hr />

<h4>一个小技巧快速定位汇编码</h4>

<p>我对intel指令集和go的编译器知之甚少，读起汇编码来颇为费劲。</p>

<p>快速定位源码对应的汇编码的位置，比较方便的就是修改一个数值，比如x=1改为x=2，前后生成的汇编码diff一下，就可以大概确定位置了</p>

<hr />

<h4>替换c++生成文件的指令</h4>

<p>在探索过程中，我想做个对比实验来证明是否上面所说的<code>dec eax</code>引起了c++和go在memory reordering上的差异，于是就想将<code>dec eax</code>也加到c++的生成文件中，这样就可以对比效果</p>

<p>碰到的问题是如果我直接将<code>asm volatile("dec %eax")</code>直接加到c++源码中，生成的汇编代码不是<code>48</code>，而是<code>FExxxx</code>。翻看<a href="http://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-vol-2a-manual.pdf">Intel® 64 and IA-32 Architectures
Software Developer’s Manual</a>，可知<code>dec</code>有多种形式</p>

<p>但是我不想研究为什么编译器会选择<code>FExxxx</code>而不是<code>48</code>，而是想尽快将c++生成的汇编代码形式做成和go一样。于是就有了下面的步骤：</p>

<ol>
<li><code>48</code>有两个字节，我也选取两个字节的op写在c++源码中，比如<code>asm volatile("cli")</code></li>
<li>c++编译生成，然后用16进制编辑器将<code>cli</code>生成的两个字节换成<code>48</code>即可</li>
</ol>


<p>之所以选择替换是因为怕有checksum或者内存位置的偏移，我也不知道有还是没有&#8230;</p>

<p>对比实验证明<code>dec eax</code>不是引起差异的原因</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[对Memory Reordering Caught in the Act的学习]]></title>
    <link href="http://ikarishinjieva.github.com/blog/blog/2013/11/07/study-memory-reorder/"/>
    <updated>2013-11-07T21:40:00+08:00</updated>
    <id>http://ikarishinjieva.github.com/blog/blog/2013/11/07/study-memory-reorder</id>
    <content type="html"><![CDATA[<p>最近迷上了preshing.com，真的是非常专业的blog，每篇深浅合适而且可以相互印证，达到出书的质量了</p>

<p>学习了<a href="http://preshing.com/20120515/memory-reordering-caught-in-the-act/">Memory Reordering Caught in the Act</a>，内容很简单，主要是说“即使汇编码是顺序的，CPU执行时会对Load-Save进行乱序执行，导致无锁的两线程出现意料之外的结果”</p>

<p>简述一下：</p>

<ul>
<li>首先我们有两个线程，Ta和Tb，且有四个公共变量，a,b,r1,r2</li>
<li>Ta的代码是 a=1, r1=b</li>
<li>Tb的代码是 b=1, r2=a</li>
<li>保证编译器不做乱序优化</li>
<li>由于两个线程的读都在写之后，那么理论上，r1和r2中至少有一个应为1，或者都为1</li>
<li>但实际并非如此</li>
</ul>


<p>原因是CPU会做乱序执行，因为Ta/Tb的代码乱序后，比如r1=b, a=1，从单线程的角度来看对结果没有影响。而对于多线程，就会出现r1=r2=0的状况</p>

<p>解决方案是在两句之间插入Load-Save fence，参看<a href="http://preshing.com/20120710/memory-barriers-are-like-source-control-operations/">这里</a></p>

<p>我自己用go想重现这个场景，代码参看最后。但是奇怪的是go的编译码跟文章描述的差不多</p>

<pre><code>[thread 1]
...
MOVQ    $1,a+0(SB)
MOVQ    b+0(SB),BX
MOVQ    BX,r1+0(SB)

[thread 2]
MOVQ    $1,b+0(SB)
MOVQ    a+0(SB),BX
MOVQ    BX,r2+0(SB)
</code></pre>

<p>但是在MBP (Intel Core i7)上跑并没有出现CPU乱序的现象，希望有同学能帮我提供线索，谢谢</p>

<p>(2013.11.11 更新：关于以上现象的原因参看<a href="http://ikarishinjieva.github.io/blog/blog/2013/11/11/study-memory-reorder-cont/">续 - 关于go的部分</a>)</p>

<p>go 代码：</p>

<pre><code>package main

import (
    "fmt"
    "math/rand"
)

var x, y, r1, r2 int
var detected = 0

func randWait() {
    for rand.Intn(8) != 0 {
    }
}

func main() {
    beginSig1 := make(chan bool, 1)
    beginSig2 := make(chan bool, 1)
    endSig1 := make(chan bool, 1)
    endSig2 := make(chan bool, 1)
    go func() {
        for {
            &lt;-beginSig1
            randWait()
            x = 1
            r1 = y
            endSig1 &lt;- true
        }
    }()
    go func() {
        for {
            &lt;-beginSig2
            randWait()
            y = 1
            r2 = x
            endSig2 &lt;- true
        }
    }()
    for i := 1; ; i = i + 1 {
        x = 0
        y = 0
        beginSig1 &lt;- true
        beginSig2 &lt;- true
        &lt;-endSig1
        &lt;-endSig2
        if r1 == 0 &amp;&amp; r2 == 0 {
            detected = detected + 1
            fmt.Println(detected, "reorders detected after ", i, "iterations")
        }
    }
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[对heartbeat φ累积失败检测算法的学习]]></title>
    <link href="http://ikarishinjieva.github.com/blog/blog/2013/11/05/accrual-failure-detector/"/>
    <updated>2013-11-05T21:50:00+08:00</updated>
    <id>http://ikarishinjieva.github.com/blog/blog/2013/11/05/accrual-failure-detector</id>
    <content type="html"><![CDATA[<p>偶尔读到了这篇&#8221;<a href="http://blog.csdn.net/chen77716/article/details/6541968">φ累积失败检测算法</a>&#8220;，写的非常不错。藉此了解了这个用于heartbeat检测的算法，在此记录一下我自己理解的简单版本</p>

<p>heartbeat时我们使用固定的时间限制t0，当heartbeat的返回时长超过t0时，就认为heartbeat失败。这个方法的弊端是：固定的t0是在事先测定的，不会随网络状况的变化而智能变化。φ累积失败检测算法就是要解决这个问题</p>

<p>失败检验算法的基本思想就是：成功判定“heartbeat失败”的概率符合<a href="http://zh.wikipedia.org/wiki/%E6%AD%A3%E6%80%81%E5%88%86%E5%B8%83">正态分布曲线</a>，x轴是本次心跳距上次心跳的差距时间，y轴是差距为x的心跳的概率。</p>

<br/>也就是说，假设我们已经有一条正态分布的曲线，当前时间是Tnow，上次心跳成功的时间是Tlast，那么从(Tlast-Tnow) ~ +∞这个区间内的积分（设为w，w<1）就代表某心跳间隔从Tlast维持到大于Tnow的时间的概率，即在Tnow时判定“heartbeat失败”的<b>失败率</b>，就是说如果我们在Tnow这个时间点判定“heartbeat失败”，那么有w的概率我们做出了错误的判定（heartbeat本该是成功的，也许只是被延迟了= =）


<p>臆测这个算法的基本步骤是：</p>

<ol>
<li>我们假设判定失败率的阈值是&lt;=10%，也就是允许我们判定“heartbeat失败”时最大失败率为10%。</li>
<li>取样本空间，比如前N次心跳的差距时间（心跳接收时间-上次心跳的接收时间）。计算这个样本空间的均值和方差，就可以计算出正态分布曲线</li>
<li>在某时间Tnow，计算(Tlast-Tnow) ~ +∞这个区间内的积分（设为w），即为判定“heartbeat失败”的<b>失败率</b>，若大于阈值10%，则可以判定“heartbeat”失败</li>
<li>重复取样，继续算法</li>
</ol>


<p>到此基本结束，以下是对原文&#8221;<a href="http://blog.csdn.net/chen77716/article/details/6541968">φ累积失败检测算法</a>&#8220;的一些个人补充</p>

<ul>
<li>原文有φ这个变量，主要是因为计算出来的判定失败率可能经常是非常小的小数，所以φ取其负对数，方便比较</li>
<li>在此不再重复引用原文的公式</li>
</ul>


<p>最后，可参考论文<a href="https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=1&amp;cad=rja&amp;ved=0CDEQFjAA&amp;url=http%3A%2F%2Fddg.jaist.ac.jp%2Fpub%2FHDY%2B04.pdf&amp;ei=L_94Uo3OGomciQLCx4GQBg&amp;usg=AFQjCNGYrM_1R5LmY4wrDlKnykatr3VBRA&amp;sig2=G8d5gBsR8MpIwgfU9Xbt7A&amp;bvm=bv.55980276,d.cGE">
The φ Accrual Failure Detector</a>：</p>

<ul>
<li>这篇论文非常详细（啰嗦）地描述了要解决的问题场景</li>
<li>这篇论文给出了一般性的累积失败检测法要满足的特性</li>
<li>这篇论文给出了用正态分布曲线来计算的步骤</li>
<li>这篇论文给出了算法正确性的比较结果</li>
</ul>


<p>最后的最后，推荐<a href="http://blog.csdn.net/chen77716">这个大牛陈国庆的blog</a>，其中文章写的质量高，里面也有对Paxos算法的介绍，配合paxos的wiki，解析的很到位</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[对Mysql bug #70307 的学习]]></title>
    <link href="http://ikarishinjieva.github.com/blog/blog/2013/10/25/study-mysql-bug-70307/"/>
    <updated>2013-10-25T22:00:00+08:00</updated>
    <id>http://ikarishinjieva.github.com/blog/blog/2013/10/25/study-mysql-bug-70307</id>
    <content type="html"><![CDATA[<p>之前描述<a href="http://ikarishinjieva.github.io/blog/blog/2013/10/11/hole-in-mysql-56-replication-dead-lock/">Mysql 5.6.15 Replication中碰到的死锁</a>的情况，这次尝试debug下原因。</p>

<h2>debug的过程</h2>

<p>用参数&#8211;gdb启动mysql，按照<a href="http://bugs.mysql.com/file.php?id=20542">步骤</a>重现bug（让slave &#8220;show slave status&#8221;时卡住）。然后用gdb attach到slave mysql实例上。</p>

<pre><code>(gdb) thread apply all bt
</code></pre>

<p>输出所有线程的backtrace，找到show slave status卡住的线程和位置</p>

<pre><code>Thread 2 (Thread 0x7f583c166700 (LWP 2440)):
#0  0x00007f583f484054 in __lll_lock_wait () from /lib64/libpthread.so.0
#1  0x00007f583f47f3be in _L_lock_995 () from /lib64/libpthread.so.0
#2  0x00007f583f47f326 in pthread_mutex_lock () from /lib64/libpthread.so.0
#3  0x0000000000aa3cde in safe_mutex_lock (mp=0x3516ae8, try_lock=0 '\000', file=0xfb8e58 "/home/vagrant/mysql-5.6.12/sql/rpl_slave.cc", line=2611) at /home/vagrant/mysql-5.6.12/mysys/thr_mutex.c:152
#4  0x0000000000a4b993 in inline_mysql_mutex_lock (that=0x3516ae8, src_file=0xfb8e58 "/home/vagrant/mysql-5.6.12/sql/rpl_slave.cc", src_line=2611) at /home/vagrant/mysql-5.6.12/include/mysql/psi/mysql_thread.h:686
#5  0x0000000000a53cb3 in show_slave_status (thd=0x352e3d0, mi=0x34b4f20) at /home/vagrant/mysql-5.6.12/sql/rpl_slave.cc:2611
#6  0x00000000007d45f4 in mysql_execute_command (thd=0x352e3d0) at /home/vagrant/mysql-5.6.12/sql/sql_parse.cc:2766
#7  0x00000000007ddc46 in mysql_parse (thd=0x352e3d0, rawbuf=0x7f57ec005010 "show slave status", length=17, parser_state=0x7f583c165660) at /home/vagrant/mysql-5.6.12/sql/sql_parse.cc:6187
#8  0x00000000007d1019 in dispatch_command (command=COM_QUERY, thd=0x352e3d0, packet=0x3534e51 "", packet_length=17) at /home/vagrant/mysql-5.6.12/sql/sql_parse.cc:1334
#9  0x00000000007d017b in do_command (thd=0x352e3d0) at /home/vagrant/mysql-5.6.12/sql/sql_parse.cc:1036
#10 0x0000000000797a08 in do_handle_one_connection (thd_arg=0x352e3d0) at /home/vagrant/mysql-5.6.12/sql/sql_connect.cc:977
#11 0x00000000007974e4 in handle_one_connection (arg=0x352e3d0) at /home/vagrant/mysql-5.6.12/sql/sql_connect.cc:893
#12 0x0000000000aea87a in pfs_spawn_thread (arg=0x351b510) at /home/vagrant/mysql-5.6.12/storage/perfschema/pfs.cc:1855
#13 0x00007f583f47d851 in start_thread () from /lib64/libpthread.so.0
#14 0x00007f583e3e890d in clone () from /lib64/libc.so.6
</code></pre>

<p>可以看到show slave status卡在</p>

<pre><code>#5  0x0000000000a53cb3 in show_slave_status (thd=0x352e3d0, mi=0x34b4f20) at /home/vagrant/mysql-5.6.12/sql/rpl_slave.cc:2611
</code></pre>

<p>查找源码可以看到show slave status卡在获取锁mi->rli->data_lock上<br/>(科普下缩写: mi=master info, rli=relay log info</p>

<p>在gdb中运行命令</p>

<pre><code>(gdb) thread 2
(gdb) f 5
(gdb) print mi-&gt;rli-&gt;data_lock
</code></pre>

<p>切换到thread 2堆栈第5层的上下文，打印出mi->rli->data_lock变量，输出如下</p>

<pre><code>$1 = {m_mutex = {global = {__data = {__lock = 0, __count = 0, __owner = 0, __nusers = 0, __kind = 2, __spins = 0,
    __list = {__prev = 0x0, __next = 0x0}},
  __size = '\000' &lt;repeats 16 times&gt;, "\002", '\000' &lt;repeats 22 times&gt;, __align = 0}, mutex = {__data = {
    __lock = 2, __count = 0, __owner = 2435, __nusers = 1, __kind = 3, __spins = 0, __list = {__prev = 0x0,
      __next = 0x0}},
  __size = "\002\000\000\000\000\000\000\000\203\t\000\000\001\000\000\000\003", '\000' &lt;repeats 22 times&gt;,
  __align = 2}, file = 0xfa4520 "/home/vagrant/mysql-5.6.12/sql/log_event.cc", line = 7259, count = 1,
thread = 140016942216960}, m_psi = 0x0}
</code></pre>

<p>看到锁的owner是线程(LWP 2435)，为Thread 3</p>

<p>Thread 3的backtrace如下</p>

<pre><code>Thread 3 (Thread 0x7f583c1a7700 (LWP 2435)):
#0  0x00007f583f4817bb in pthread_cond_timedwait@@GLIBC_2.3.2 () from /lib64/libpthread.so.0
#1  0x0000000000aa429d in safe_cond_timedwait (cond=0x7f57f4000ba8, mp=0x7f57f4000b38, abstime=0x7f583c1a60f0, file=0xedc960 "/home/vagrant/mysql-5.6.12/include/mysql/psi/mysql_thread.h", line=1199) at /home/vagrant/mysql-5.6.12/mysys/thr_mutex.c:278
#2  0x00000000007121f4 in inline_mysql_cond_timedwait (that=0x7f57f4000ba8, mutex=0x7f57f4000b38, abstime=0x7f583c1a60f0, src_file=0xedcb98 "/home/vagrant/mysql-5.6.12/sql/mdl.cc", src_line=1306) at /home/vagrant/mysql-5.6.12/include/mysql/psi/mysql_thread.h:1199
#3  0x0000000000713111 in MDL_wait::timed_wait (this=0x7f57f4000b38, owner=0x7f57f4000a50, abs_timeout=0x7f583c1a60f0, set_status_on_timeout=true, wait_state_name=0x14d0488) at /home/vagrant/mysql-5.6.12/sql/mdl.cc:1306
#4  0x0000000000714811 in MDL_context::acquire_lock (this=0x7f57f4000b38, mdl_request=0x7f583c1a6180, lock_wait_timeout=31536000) at /home/vagrant/mysql-5.6.12/sql/mdl.cc:2241
#5  0x000000000063656a in ha_commit_trans (thd=0x7f57f4000a50, all=true) at /home/vagrant/mysql-5.6.12/sql/handler.cc:1396 (COMMIT LOCK)
#6  0x00000000008a010b in trans_commit (thd=0x7f57f4000a50) at /home/vagrant/mysql-5.6.12/sql/transaction.cc:228
#7  0x0000000000a081bb in Xid_log_event::do_commit (this=0x7f57f4004730, thd=0x7f57f4000a50) at /home/vagrant/mysql-5.6.12/sql/log_event.cc:7174
#8  0x0000000000a0886e in Xid_log_event::do_apply_event (this=0x7f57f4004730, rli=0x3516650) at /home/vagrant/mysql-5.6.12/sql/log_event.cc:7310 (rli-&gt;data_lock)
#9  0x00000000009fd956 in Log_event::apply_event (this=0x7f57f4004730, rli=0x3516650) at /home/vagrant/mysql-5.6.12/sql/log_event.cc:3049
#10 0x0000000000a55e31 in apply_event_and_update_pos (ptr_ev=0x7f583c1a68a0, thd=0x7f57f4000a50, rli=0x3516650) at /home/vagrant/mysql-5.6.12/sql/rpl_slave.cc:3374
#11 0x0000000000a56e45 in exec_relay_log_event (thd=0x7f57f4000a50, rli=0x3516650) at /home/vagrant/mysql-5.6.12/sql/rpl_slave.cc:3742
#12 0x0000000000a5c334 in handle_slave_sql (arg=0x34b4f20) at /home/vagrant/mysql-5.6.12/sql/rpl_slave.cc:5552
#13 0x0000000000aea87a in pfs_spawn_thread (arg=0x350a800) at /home/vagrant/mysql-5.6.12/storage/perfschema/pfs.cc:1855
#14 0x00007f583f47d851 in start_thread () from /lib64/libpthread.so.0
#15 0x00007f583e3e890d in clone () from /lib64/libc.so.6
</code></pre>

<p>可以看到Thread 3卡在commit lock上，同时查源码看到Thread 3同时占有了rli->data_lock (log_event.cc:7259)</p>

<h2>锁的状态</h2>

<p>按照bug的描述，</p>

<ol>
<li>flush tables with read lock; 会持有commit lock</li>
<li>IO thread (Thread 3)会持有rli->data_lock，并等待commit lock</li>
<li>show slave status; 会等待rli->data_lock</li>
</ol>


<p>结果导致show slave status卡住不可用</p>

<h2>臆测一下解决方法</h2>

<p>鉴于功底不深，只能臆测一下</p>

<ol>
<li>IO thread持有锁rli->data_lock的原因是要更新relay log的状态，然后进行commit(Xid_log_event::do_apply_event (log_event.cc:7248))。在commit的时候不会更新rli的数据。</li>
<li>show slave status不会更新rli的数据，需要锁rli->data_lock的原因是要一致性数据。</li>
</ol>


<p>因此可能的解决方案是IO thread持有读写锁，进行commit时转为持有读锁。show slave status只使用读锁。</p>

<p>只是臆测下解决方法，待<a href="http://bugs.mysql.com/bug.php?id=70307">bug #70307</a>修掉时再学习。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mysql 5.6.12 master上flush logs在slave上产生两个relay-log]]></title>
    <link href="http://ikarishinjieva.github.com/blog/blog/2013/10/22/mysql-flush-logs-make-two-relay-log-file/"/>
    <updated>2013-10-22T21:42:00+08:00</updated>
    <id>http://ikarishinjieva.github.com/blog/blog/2013/10/22/mysql-flush-logs-make-two-relay-log-file</id>
    <content type="html"><![CDATA[<h2>现象</h2>

<p>一个碰巧观察到的有趣的现象：mysql 5.6.12 在master上flush logs，在slave上会观察到两个新的relay-log file</p>

<p>举例：</p>

<p>slave-relay-bin.000092</p>

<pre><code> FD event
 Rotate to mysql-bin.000056
 Rotate to slave-relay-bin.000093
</code></pre>

<p>slave-relay-bin.000093</p>

<pre><code> FD event slave
 Rotate to mysql-bin.000056
 FD event master
 bla bla…
</code></pre>

<p>可以看到000092这个relay log相当多余。这个现象并不会影响replication的正确性，只是让有强迫症的人有点狂躁</p>

<h2>探索</h2>

<p>在master上net_serv.cc:my_net_write打断点，可以观察到master的确发出了以下三个事件</p>

<ul>
<li>ROTATE_EVENT</li>
</ul>


<p>backtrace</p>

<pre><code>#0  my_net_write (net=0x1ea2858, packet=0x7fffa4002b70 "", len=48)
    at /home/vagrant/mysql-5.6.12/sql/net_serv.cc:284
#1  0x0000000000a48b05 in mysql_binlog_send (thd=0x1ea2600, log_ident=0x7fffa4004c60 "mysql-bin.000052", pos=167,
    slave_gtid_executed=0x0) at /home/vagrant/mysql-5.6.12/sql/rpl_master.cc:1336
#2  0x0000000000a46ad2 in com_binlog_dump (thd=0x1ea2600, packet=0x1ea5d21 "", packet_length=26)
    at /home/vagrant/mysql-5.6.12/sql/rpl_master.cc:746
#3  0x00000000007d1ab9 in dispatch_command (command=COM_BINLOG_DUMP, thd=0x1ea2600, packet=0x1ea5d21 "",
    packet_length=26) at /home/vagrant/mysql-5.6.12/sql/sql_parse.cc:1534
#4  0x00000000007d017b in do_command (thd=0x1ea2600) at /home/vagrant/mysql-5.6.12/sql/sql_parse.cc:1036
#5  0x0000000000797a08 in do_handle_one_connection (thd_arg=0x1ea2600)
    at /home/vagrant/mysql-5.6.12/sql/sql_connect.cc:977
#6  0x00000000007974e4 in handle_one_connection (arg=0x1ea2600)
    at /home/vagrant/mysql-5.6.12/sql/sql_connect.cc:893
#7  0x0000000000aea87a in pfs_spawn_thread (arg=0x1e7aa80)
    at /home/vagrant/mysql-5.6.12/storage/perfschema/pfs.cc:1855
#8  0x00007ffff7bc7851 in start_thread () from /lib64/libpthread.so.0
#9  0x00007ffff6b3290d in clone () from /lib64/libc.so.6
</code></pre>

<ul>
<li>第二个ROTATE_EVENT</li>
</ul>


<p>backtrace</p>

<pre><code>#0  my_net_write (net=0x1ea2858, packet=0x7fffa4002ab0 "", len=48)
    at /home/vagrant/mysql-5.6.12/sql/net_serv.cc:284
#1  0x0000000000a45f04 in fake_rotate_event (net=0x1ea2858, packet=0x1ea2be8,
    log_file_name=0x7fffc94ff270 "./mysql-bin.000056", position=4, errmsg=0x7fffc94ffdb0,
    checksum_alg_arg=1 '\001') at /home/vagrant/mysql-5.6.12/sql/rpl_master.cc:395
#2  0x0000000000a4a33d in mysql_binlog_send (thd=0x1ea2600, log_ident=0x7fffa4004c60 "mysql-bin.000052", pos=167,
    slave_gtid_executed=0x0) at /home/vagrant/mysql-5.6.12/sql/rpl_master.cc:1728
#3  0x0000000000a46ad2 in com_binlog_dump (thd=0x1ea2600, packet=0x1ea5d21 "", packet_length=26)
    at /home/vagrant/mysql-5.6.12/sql/rpl_master.cc:746
#4  0x00000000007d1ab9 in dispatch_command (command=COM_BINLOG_DUMP, thd=0x1ea2600, packet=0x1ea5d21 "",
    packet_length=26) at /home/vagrant/mysql-5.6.12/sql/sql_parse.cc:1534
#5  0x00000000007d017b in do_command (thd=0x1ea2600) at /home/vagrant/mysql-5.6.12/sql/sql_parse.cc:1036
#6  0x0000000000797a08 in do_handle_one_connection (thd_arg=0x1ea2600)
    at /home/vagrant/mysql-5.6.12/sql/sql_connect.cc:977
#7  0x00000000007974e4 in handle_one_connection (arg=0x1ea2600)
    at /home/vagrant/mysql-5.6.12/sql/sql_connect.cc:893
#8  0x0000000000aea87a in pfs_spawn_thread (arg=0x1e7aa80)
    at /home/vagrant/mysql-5.6.12/storage/perfschema/pfs.cc:1855
#9  0x00007ffff7bc7851 in start_thread () from /lib64/libpthread.so.0
#10 0x00007ffff6b3290d in clone () from /lib64/libc.so.6
</code></pre>

<ul>
<li>FORMAT_DESCRIPTION_EVENT</li>
</ul>


<p>可以看到第一个ROTATE_EVENT是由flush logs发出的，第二个ROTATE_EVENT是fake_rotate_event</p>

<h2>关于fake_rotate_event</h2>

<p>以前也<a href="http://ikarishinjieva.github.io/blog/blog/2013/10/16/mysql-mysql_binlog_send-src/">吐槽</a>过fake_rotate_event</p>

<p>master在binlog切换时（不一定是手工flush，也可能是重启，或者容量达到限制）一定要多发一个rotate event，原因如源码rpl_master.cc:mysql_binlog_send中的注释</p>

<pre><code>  /*
    Call fake_rotate_event() in case the previous log (the one which
    we have just finished reading) did not contain a Rotate event.
    There are at least two cases when this can happen:

    - The previous binary log was the last one before the master was
      shutdown and restarted.

    - The previous binary log was GTID-free (did not contain a
      Previous_gtids_log_event) and the slave is connecting using
      the GTID protocol.

    This way we tell the slave about the new log's name and
    position.  If the binlog is 5.0 or later, the next event we
    are going to read and send is Format_description_log_event.
  */
  if ((file=open_binlog_file(&amp;log, log_file_name, &amp;errmsg)) &lt; 0 ||
      fake_rotate_event(net, packet, log_file_name, BIN_LOG_HEADER_SIZE,
                        &amp;errmsg, current_checksum_alg))
</code></pre>

<p>主要是解决之前没有rotate event发送的场景</p>

<p>虽然非常想吐槽，但是我也想不出更好的办法</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mysql rpl_slave.cc:handle_slave_io 源码的一些个人分析]]></title>
    <link href="http://ikarishinjieva.github.com/blog/blog/2013/10/20/mysql-handle_slave_io-src/"/>
    <updated>2013-10-20T20:17:00+08:00</updated>
    <id>http://ikarishinjieva.github.com/blog/blog/2013/10/20/mysql-handle_slave_io-src</id>
    <content type="html"><![CDATA[<p>读了rpl_slave.cc:handle_slave_io的源码（Mysql 5.6.11），总结一下</p>

<h2>函数概述</h2>

<p>handle_slave_io是slave io_thread的主函数，函数逻辑入口为rpl_slave.cc:start_slave_threads</p>

<h2>主体结构</h2>

<figure class='code'><figcaption><span>源码的主体结构  </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">handle_slave_io</span><span class="o">(</span><span class="n">master_info</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>     <span class="mi">3955</span> <span class="n">bla</span> <span class="n">bla</span><span class="err">…</span>
</span><span class='line'>     <span class="mi">4016</span> <span class="n">fire</span> <span class="n">HOOK</span> <span class="n">binlog_relay_io</span><span class="o">.</span><span class="na">thread_start</span>
</span><span class='line'>     <span class="mi">4032</span> <span class="err">与</span><span class="n">master</span><span class="err">建立连接</span>
</span><span class='line'>    <span class="o">(</span><span class="mi">4047</span> <span class="err">设置</span><span class="n">max_packet_size</span><span class="o">)</span>
</span><span class='line'>     <span class="mi">4073</span> <span class="n">get_master_version_and_clock</span><span class="o">,</span>
</span><span class='line'>          <span class="err">在</span><span class="n">master</span><span class="err">上：</span>
</span><span class='line'>          <span class="err">通过</span><span class="n">SELECT</span> <span class="n">UNIX_TIMESTAMP</span><span class="o">()</span><span class="err">获取</span><span class="n">server</span> <span class="n">timestamp</span>
</span><span class='line'>          <span class="err">通过</span><span class="n">SHOW</span> <span class="n">VARIABLES</span> <span class="n">LIKE</span> <span class="err">&#39;</span><span class="n">SERVER_ID</span><span class="err">&#39;获取</span><span class="n">server</span> <span class="n">id</span>
</span><span class='line'>          <span class="n">SET</span> <span class="nd">@master_heartbeat_period</span><span class="o">=</span> <span class="o">?</span>
</span><span class='line'>          <span class="n">SET</span> <span class="nd">@master_binlog_checksum</span><span class="o">=</span> <span class="err">@</span><span class="nd">@global.binlog_checksum</span>
</span><span class='line'>          <span class="n">SELECT</span> <span class="nd">@master_binlog_checksum</span><span class="err">获取</span><span class="n">master</span> <span class="n">binlog</span> <span class="n">checksum</span>
</span><span class='line'>          <span class="n">SELECT</span> <span class="err">@</span><span class="nd">@GLOBAL.GTID_MODE</span>
</span><span class='line'>     <span class="mi">4075</span> <span class="n">get_master_uuid</span>
</span><span class='line'>          <span class="err">在</span><span class="n">master</span><span class="err">上“</span><span class="n">SHOW</span> <span class="n">VARIABLES</span> <span class="n">LIKE</span> <span class="err">&#39;</span><span class="n">SERVER_UUID</span><span class="err">&#39;”</span>
</span><span class='line'>     <span class="mi">4077</span> <span class="n">io_thread_init_commands</span>
</span><span class='line'>          <span class="err">在</span><span class="n">master</span><span class="err">上“</span><span class="n">SET</span> <span class="nd">@slave_uuid</span><span class="o">=</span> <span class="err">&#39;</span><span class="o">%</span><span class="n">s</span><span class="err">&#39;”</span>
</span><span class='line'>     <span class="mi">4106</span> <span class="n">register_slave_on_master</span>
</span><span class='line'>          <span class="err">向</span><span class="n">master</span><span class="err">发送</span><span class="n">COM_REGISTER_SLAVE</span>
</span><span class='line'>     <span class="mi">4133</span> <span class="k">while</span> <span class="o">(!</span><span class="n">io_slave_killed</span><span class="o">(</span><span class="n">thd</span><span class="o">,</span><span class="n">mi</span><span class="o">))</span>
</span><span class='line'>     <span class="mi">4134</span> <span class="o">{</span>
</span><span class='line'>     <span class="mi">4136</span>      <span class="n">request_dump</span>
</span><span class='line'>               <span class="err">向</span><span class="n">master</span><span class="err">发送</span><span class="n">COM_BINLOG_DUMP_GTID</span><span class="o">/</span><span class="n">COM_BINLOG_DUMP</span>
</span><span class='line'>     <span class="mi">4159</span>      <span class="k">while</span> <span class="o">(!</span><span class="n">io_slave_killed</span><span class="o">(</span><span class="n">thd</span><span class="o">,</span><span class="n">mi</span><span class="o">))</span>
</span><span class='line'>     <span class="mi">4160</span>      <span class="o">{</span>
</span><span class='line'>     <span class="mi">4169</span>           <span class="n">read_event</span><span class="err">，此为阻塞方法，会阻塞等待有新数据包传入</span>
</span><span class='line'>     <span class="mi">4184</span>          <span class="o">{</span>
</span><span class='line'>                         <span class="err">一些包错误的处理，包括</span><span class="n">packet</span> <span class="n">too</span> <span class="n">large</span> <span class="o">/</span> <span class="n">out</span> <span class="n">of</span> <span class="n">resource</span><span class="err">等</span>
</span><span class='line'>     <span class="mi">4213</span>          <span class="o">}</span>
</span><span class='line'>     <span class="mi">4219</span>          <span class="n">fire</span> <span class="n">HOOK</span> <span class="n">binlog_relay_io</span><span class="o">.</span><span class="na">after_read_event</span>
</span><span class='line'>     <span class="mi">4232</span>          <span class="n">queue_event</span><span class="err">，将</span><span class="n">event</span><span class="err">放入</span><span class="n">relay</span> <span class="n">log</span><span class="err">写</span><span class="n">buf</span>
</span><span class='line'>     <span class="mi">4240</span>          <span class="n">fire</span> <span class="n">HOOK</span> <span class="n">binlog_relay_io</span><span class="o">.</span><span class="na">after_queue_event</span>
</span><span class='line'>     <span class="mi">4250</span>          <span class="n">flush_master_info</span><span class="err">，将</span><span class="n">master_info</span><span class="err">和</span><span class="n">relay</span> <span class="n">log</span><span class="err">刷到</span><span class="n">disk</span><span class="err">上</span>
</span><span class='line'>                   <span class="err">此处，先刷</span><span class="n">relay</span> <span class="n">log</span><span class="err">，后刷</span><span class="n">master_info</span><span class="err">。这样意外的故障可以通过重连恢复机制来恢复。</span>
</span><span class='line'>                   <span class="err">若先刷</span><span class="n">master_info</span><span class="err">，后刷</span><span class="n">relay</span> <span class="n">log</span><span class="err">，意外故障时</span><span class="n">master_info</span><span class="err">已经更新，比如</span><span class="o">(</span><span class="mi">0</span><span class="o">-</span><span class="mi">100</span><span class="o">,</span> <span class="mi">100</span><span class="o">-</span><span class="mi">200</span><span class="o">)</span><span class="err">，而数据丢失，仅有</span><span class="o">(</span><span class="mi">0</span><span class="o">-</span><span class="mi">100</span><span class="o">)</span><span class="err">，恢复的</span><span class="n">replication</span><span class="err">会从</span><span class="mi">200</span><span class="err">开始。整个</span><span class="n">relay</span> <span class="n">log</span><span class="err">会成为</span><span class="o">(</span><span class="mi">0</span><span class="o">-</span><span class="mi">100</span><span class="o">,</span> <span class="mi">200</span><span class="o">-)</span><span class="err">，中间数据会丢失。</span>
</span><span class='line'>
</span><span class='line'>     <span class="mi">4286</span>          <span class="err">若</span><span class="n">relay</span> <span class="n">log</span><span class="err">达到容量限制，则</span><span class="n">wait_for_relay_log_space</span>
</span><span class='line'>     <span class="mi">4292</span>      <span class="o">}</span>
</span><span class='line'>     <span class="mi">4293</span> <span class="o">}</span>
</span><span class='line'>     <span class="mi">4296</span> <span class="err">之后都是收尾操作</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>一些重点</h2>

<ol>
<li>此处不分析锁什么的，因为看不懂</li>
<li>4047 设置max_packet_size的目的不明</li>
<li>4073 开始slave会向master直接发送一些sql，然后解析返回。而不是包装在某个包的某个字段里，用一些预定义的变量来传递结果。<br/>这种设计一下就觉得山寨起来。<br/>后经同事 @神仙 指点，mysql这样做貌似是为了兼容性，免得数据包格式被改来改去。<br/>（看到mysql里大量的兼容代码都拿来处理包结构的问题，最极品的可能是莫过于LOG_EVENT_MINIMAL_HEADER_LEN了）<br/>在对流量影响不大的情况下，直接用sql反复查询的确是个好的解决手法</li>
<li>4250 将master_info和relay log刷到disk上。<br/>先刷relay log，后刷master_info。这样意外的故障可以通过relay log恢复机制来恢复。<br/>若先刷master_info，后刷relay log，意外故障时master_info已经更新，比如(0-100, 100-200)，而数据(100-200)丢失，仅有(0-100)，恢复的replication会从200开始。整个relay log会成为(0-100, 200-)，中间数据会丢失。</li>
</ol>


<h2>start slave时slave向master发送的事件</h2>

<ul>
<li><p>SELECT UNIX_TIMESTAMP() (rpl_slave.cc:get_master_version_and_clock)</p></li>
<li> SHOW VARIABLES LIKE &#8216;SERVER_ID&#8217; (rpl_slave.cc:get_master_version_and_clock)</li>
<li> SET @master_heartbeat_period=? (rpl_slave.cc:get_master_version_and_clock)</li>
<li> SET @master_binlog_checksum= @@global.binlog_checksum (rpl_slave.cc:get_master_version_and_clock)</li>
<li> SELECT @master_binlog_checksum (rpl_slave.cc:get_master_version_and_clock)</li>
<li> SELECT @@GLOBAL.GTID_MODE (rpl_slave.cc:get_master_version_and_clock)</li>
<li><p> SHOW VARIABLES LIKE &#8216;SERVER_UUID&#8217; （rpl_slave.cc:get_master_uuid）</p></li>
<li><p> SET @slave_uuid= &#8216;%s&#8217;（rpl_slave.cc:io_thread_init_commands)</p></li>
<li> COM_REGISTER_SLAVE(rpl_slave.cc:register_slave_on_master)</li>
<li> COM_BINLOG_DUMP(rpl_slave.cc:request_dump)</li>
</ul>


<h2>master与slave的时间差</h2>

<p>可以看到slave获得master的时间方法就是直接下sql，完全忽略网络延迟等等等等，属于不精准的时间</p>

<p><a href="http://guduwhuzhe.iteye.com/blog/1901707">这篇文章</a>从源码级别分析了Seconds_Behind_Master的来源，也给出了备库延迟跳跃的原因。总的来说就是Seconds_Behind_Master不可信。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mysql rpl_master.cc:mysql_binlog_send 源码的一些个人分析和吐槽]]></title>
    <link href="http://ikarishinjieva.github.com/blog/blog/2013/10/16/mysql-mysql_binlog_send-src/"/>
    <updated>2013-10-16T22:50:00+08:00</updated>
    <id>http://ikarishinjieva.github.com/blog/blog/2013/10/16/mysql-mysql_binlog_send-src</id>
    <content type="html"><![CDATA[<p>读了两天rpl_master.cc:mysql_binlog_send的源码（Mysql 5.6.11），总结一下</p>

<p>函数的入口是rpl_master.cc:com_binlog_dump，当slave向master请求数据时，在master上调用</p>

<p>函数参数说明: <br/>log_ident为slave请求的binlog文件名，如&#8221;mysql-bin.000001&#8221;<br/>pos为slave请求的binlog位置<br/>slave_gtid_executed为gtid相关，在此忽略</p>

<p>在此吐槽：</p>

<ol>
<li>这个函数将近1k行，且缩进混乱，代码折叠困难。最后附的我的笔记中，有整理好的源码下载</li>
<li>这个函数有两大段近百行的重复代码（1179 &amp; 1553）</li>
</ol>


<h1>源码的主体结构</h1>

<figure class='code'><figcaption><span>源码的主体结构  </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">mysql_binlog_send</span><span class="o">(</span><span class="err">…</span><span class="o">)</span>
</span><span class='line'><span class="o">{</span>
</span><span class='line'>     <span class="mi">0814</span> <span class="err">…</span> <span class="n">bla</span> <span class="n">bla</span>
</span><span class='line'>     <span class="mi">1011</span> <span class="n">fake_rotate_event</span>
</span><span class='line'>     <span class="mi">1028</span> <span class="n">max_alloed_packet</span><span class="o">=</span> <span class="n">MAX_MAX_ALLOWED_PACKET</span>
</span><span class='line'>     <span class="mi">1038</span> <span class="k">if</span> <span class="o">(</span><span class="err">请求的</span><span class="n">POS</span><span class="err">不是从</span><span class="n">binlog</span><span class="err">开头开始</span><span class="o">)</span>
</span><span class='line'>     <span class="mi">1039</span> <span class="o">{</span>
</span><span class='line'>               <span class="err">从</span><span class="n">binlog</span><span class="err">开头中找到一个</span><span class="n">FD</span> <span class="n">event</span><span class="o">(</span><span class="n">FORMAT_DESCRIPTION_EVENT</span><span class="o">),</span> <span class="err">并发送给</span><span class="n">slave</span>
</span><span class='line'>     <span class="mi">1123</span> <span class="o">}</span>
</span><span class='line'>     <span class="mi">1124</span> <span class="k">else</span>
</span><span class='line'>     <span class="mi">1125</span> <span class="o">{</span>
</span><span class='line'>               <span class="n">FD</span> <span class="n">event</span><span class="err">可以从正常的</span><span class="n">replication</span><span class="err">中传送给</span><span class="n">slave</span><span class="err">，此处不做操作</span>
</span><span class='line'>     <span class="mi">1127</span> <span class="o">}</span>
</span><span class='line'>     <span class="mi">1132</span> <span class="k">while</span> <span class="o">(</span><span class="n">net</span><span class="err">和</span><span class="n">the</span><span class="err">都在运转</span><span class="o">)</span>
</span><span class='line'>     <span class="mi">1133</span> <span class="o">{</span>
</span><span class='line'>     <span class="mi">1143</span>      <span class="k">while</span> <span class="o">(</span><span class="err">从</span><span class="n">binlog</span><span class="err">中读取一个</span><span class="n">event</span><span class="o">)</span>
</span><span class='line'>     <span class="mi">1144</span>      <span class="o">{</span>
</span><span class='line'>     <span class="mi">1178</span>           <span class="k">switch</span> <span class="o">(</span><span class="n">event_type</span><span class="o">)</span>
</span><span class='line'>     <span class="mi">1179</span>           <span class="o">{</span>
</span><span class='line'>                         <span class="err">分类型处理</span><span class="n">event</span>
</span><span class='line'>     <span class="mi">1281</span>           <span class="o">}</span>
</span><span class='line'>     <span class="mi">1283</span>           <span class="err">若</span><span class="n">event</span><span class="err">需跳转到下一个</span><span class="n">binlog</span><span class="o">(</span><span class="n">goto_next_binlog</span><span class="o">),</span> <span class="k">break</span>
</span><span class='line'>     <span class="mi">1291</span>           <span class="n">fire</span> <span class="n">HOOK</span> <span class="n">before_send_event</span>
</span><span class='line'>     <span class="mi">1300</span>           <span class="err">记录</span><span class="n">skip_group</span>
</span><span class='line'>     <span class="mi">1306</span>           <span class="o">{</span>
</span><span class='line'>                         <span class="n">send</span> <span class="n">last</span> <span class="n">skip</span> <span class="n">group</span> <span class="n">heartbeat</span><span class="o">?</span>
</span><span class='line'>     <span class="mi">1326</span>           <span class="o">}</span>
</span><span class='line'>     <span class="mi">1331</span>           <span class="err">向</span><span class="n">slave</span><span class="err">发送</span><span class="n">event</span>
</span><span class='line'>     <span class="mi">1348</span>           <span class="o">{</span>
</span><span class='line'>                         <span class="err">处理</span><span class="n">LOAD_EVENT</span>
</span><span class='line'>     <span class="mi">1356</span>           <span class="o">}</span>
</span><span class='line'>     <span class="mi">1358</span>           <span class="n">fire</span> <span class="n">HOOK</span> <span class="n">after_send_event</span>
</span><span class='line'>     <span class="mi">1369</span>      <span class="o">}</span>
</span><span class='line'>     <span class="mi">1391</span>      <span class="k">if</span> <span class="o">(!</span><span class="n">goto_next_binlog</span><span class="o">)</span>
</span><span class='line'>     <span class="mi">1392</span>      <span class="o">{</span>
</span><span class='line'>                   <span class="err">发送完所有</span><span class="n">binlog</span><span class="err">，未发生</span><span class="n">binlog</span><span class="err">切换时</span>
</span><span class='line'>     <span class="mi">1437</span>          <span class="err">加锁尝试再读取一个</span><span class="n">event</span><span class="err">（此时其他进程不能更新</span><span class="n">binlog</span><span class="err">），目的是试探之前处理过程中</span><span class="n">master</span><span class="err">上是否有更多的</span><span class="n">binlog</span><span class="err">写入，若有，则跳转</span><span class="mi">1553</span><span class="err">处理</span><span class="n">read_packet</span>
</span><span class='line'>     <span class="mi">1451</span>          <span class="err">若没有更多的</span><span class="n">binlog</span>
</span><span class='line'>                   <span class="o">{</span>
</span><span class='line'>                        <span class="err">等待更多的</span><span class="n">binlog</span><span class="err">写入，等待时发送心跳</span>
</span><span class='line'>     <span class="mi">1545</span>          <span class="o">}</span>
</span><span class='line'>     <span class="mi">1553</span>          <span class="err">处理</span><span class="n">read_packet</span>
</span><span class='line'>                   <span class="o">{</span>
</span><span class='line'>                        <span class="err">分类型处理</span><span class="n">event</span>
</span><span class='line'>     <span class="mi">1682</span>          <span class="o">}</span>
</span><span class='line'>     <span class="mi">1683</span>      <span class="o">}</span>
</span><span class='line'>     <span class="mi">1685</span>      <span class="k">if</span> <span class="o">(</span><span class="n">goto_next_binlog</span><span class="o">)</span>
</span><span class='line'>               <span class="o">{</span>
</span><span class='line'>                    <span class="err">切换到下一个</span><span class="n">binlog</span>
</span><span class='line'>               <span class="o">}</span>
</span><span class='line'>     <span class="mi">1733</span> <span class="o">}</span>
</span><span class='line'>     <span class="mi">1735</span> <span class="err">之后是收尾处理</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h1>重点步骤</h1>

<ol>
<li>补发Format Description event。<br/>如果传送从binlog开头开始，那么FD event会正常随着binlog传送；<br/>若传送不从binlog开头开始，则需要补发一个FD event，才开始传送</li>
<li>如何判断binlog读取完<br/>函数先不加锁读取binlog中的event，读完后，再加锁尝试读取一个event（加锁过程中，没有其他进程写进binlog），若有数据，则继续处理，若没有数据，则说明binlog读取完了，master会阻塞等待新的binlog写入。<br/>这样做主要为了：<br/>1. 不需要一直加锁读取binlog，保障性能；<br/>2. 无锁读取时会有其他进程写binlog，加锁可以保障这些新加的binlog得到妥善安置</li>
<li>心跳<br/>仅在不传送binlog时（master穷尽了binlog，开始阻塞等待新的binlog写入时）才进行心跳</li>
<li>Fake Rotate Event<br/>Fake Rotate Event在开始传送和切换binlog时发送到slave。主要作用是通知slave binlog filename，原因在源码comment里写的很清楚。但是很疑惑的是为什么在FD event里并没有binlog filename，这个问题发到了<a href="http://stackoverflow.com/questions/19375951/in-mysql-replication-why-format-description-event-doesnt-include-binlogs-name">StackoverFlow</a>，未有答案。（诶，看看我的stackoverflow的记录就知道，我的问题都是死题）</li>
</ol>


<h1>TODO</h1>

<p>有一些东西还是没弄懂，得慢慢读懂其他机制才可以，比如</p>

<ol>
<li>max_alloed_packet是如何作用的</li>
<li>send last skip group heartbeat的作用</li>
<li>不同类型的event的具体处理，需要和slave端结合在一起</li>
</ol>


<h1>我的笔记</h1>

<p>我的笔记<a href="https://app.yinxiang.com/shard/s11/sh/f23e9619-9c3d-47f5-a911-8945d0ee02a5/f4eb8539fb2f99e1481496c994b2c270">在此</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MHA failover时做了些啥]]></title>
    <link href="http://ikarishinjieva.github.com/blog/blog/2013/10/14/mha-failover/"/>
    <updated>2013-10-14T21:39:00+08:00</updated>
    <id>http://ikarishinjieva.github.com/blog/blog/2013/10/14/mha-failover</id>
    <content type="html"><![CDATA[<p>读了MHA failover部分的源码整理一下</p>

<p>代码位置注解的格式为file_name@function_name</p>

<h1>设定场景</h1>

<p>假设集群里有四个mysql实例分别是old_master和slave 0,1,2
slave 0,1,2 执行failover中的角色分别为 Latest slave, Oldest slave 和 New master</p>

<p>如图
<img src="http://ikarishinjieva.github.com/blog/images/2013-10-14-mha-failover-1.png"></p>

<h1>Failover的步骤代码</h1>

<p>(MasterFailover@do_master_failover)</p>

<p> 1  check_settings</p>

<p> 2  force_shutdown</p>

<p> 3.1    check_set_latest_slaves</p>

<p> 3.2    save_master_binlog</p>

<p> 3.3    Determining New Master Phase</p>

<pre><code>3.3.1 find_latest_base_slave

3.3.2 select_new_master

3.3.3 recover_master

3.3.4 $new_master-&gt;{activated} = 1;
</code></pre>

<p> 4  Slaves Recovery Phase</p>

<p>   4.1 Starting Parallel Slave Diff Log Generation Phase.</p>

<p>   4.2 Starting Parallel Slave Log Apply Phase.</p>

<p> 5  cleanup</p>

<h1>Failover的一些步骤说明</h1>

<p>2  force_shutdown</p>

<pre><code>2.1  对所有slave, stop io thread.(MasterFailover@force_shutdown) 这里仅stop io thread, 而不是stop slave, 尽可能让sql thread运行。sql thread是在recover必要时（要生成差异数据时）才停下。 

2.2  在Old master上回收动态ip, shutdown（并可选用power manager对Old master进行关机）. (MasterFailover@force_shutdown_internal)
</code></pre>

<p>3.1  check_set_latest_slaves, 确定latest_slave和oldest_slaves. latest_slave指的是slave中relay log最超前的slave, 相反oldest_slave指的是relay log最落后的slave</p>

<p>3.2  save_master_binlog, 保存Latest slave到Old master的binlog差异数据, 如图中蓝色部分. 由于master可能是硬件故障等, 不一定能响应save_master_binlog, 所以蓝色部分不一定能保存下来. 若失败, 之后的步骤中用到蓝色部分的地方都可以忽略, 最终结果也是会有部分数据的丢失</p>

<p>3.3.1  find_latest_base_slave, 这里最理想的状况是能从所有的latest slave中能找到一个relay log可以用于补齐oldest slave的 （如果oldest slave可以被补齐, 那其他的slave都可以被补齐）. 如场景图中所示，Slave 0可以作为latest_base_slave.</p>

<p>另一种情况是不能用于补齐oldest slave, 比如下图的状况, 集群里最全最新的relay log也无法和oldest slave对接上. 这种情况的处理跟ignore_fail配置有关, 若所有努力都失败只好failover失败</p>

<p>关于ignore_fail的处理逻辑，可参看源码或者文后我附的源码笔记
<img src="http://ikarishinjieva.github.com/blog/images/2013-10-14-mha-failover-2.png"></p>

<p>3.3.2  select_new_master, 选举new master.</p>

<p>选举的策略是尽量在candidate slave列表中，尽量在latest slave列表中，不可以在bad列表中. 注意，new master可以不是latest slave, 场景图中列举的是这种情况（尽管应该比较少见）</p>

<p>3.3.3  recover_master. 将差异数据补齐到new master, 让new master成为集群里数据最全最新的节点.</p>

<p>生成old_master上exec relay_log到read relay_log的差异数据（原因是sql thread落后于io thread）, 源码中中称为diff_from_exec_to_read, 如图中绿色部分.</p>

<p>生成old_master到latest_base_slave的差异数据(MasterFailover@recover_relay_logs), 如图中黄色部分.</p>

<p>重放: 在old_master上重放绿色部分, 然后重放黄色部分(MasterFailover@send_binlog &amp; MasterFailover@recover_slave), 最后重放蓝色部分（MasterFailover@apply_diff）</p>

<p>4  对所有的slave, 这里是以old_slave为例, 与recover_master类似：生成diff_from_exec_to_read（黑色部分）, 生成与latest_base_slave的差异数据（红色部分）. 然后重放黑色部分，红色部分和蓝色部分. (MasterFailover@recover_slaves)</p>

<p>最后让所有slave连到新的master上</p>

<h1>一点说明</h1>

<ol>
<li>只是简单记录了failover的基本操作, 仅在2.1里说明了stop io thread. 代码中其他操作如change master的操作可以直接翻代码翻到, 不穷举</li>
<li>我阅读代码的原始笔记放在<a href="https://app.yinxiang.com/shard/s11/sh/565c2973-fae1-452c-9f3e-8418fbb04360/11b9fd4b99229f8599c8c96a7bc3c72e">evernote公开页面</a>, 里面有一些细节, 不再整理</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[jruby backtick + jre 6 会卡住]]></title>
    <link href="http://ikarishinjieva.github.com/blog/blog/2013/10/11/jruby-175-jre-6-stdin-bug/"/>
    <updated>2013-10-11T22:03:00+08:00</updated>
    <id>http://ikarishinjieva.github.com/blog/blog/2013/10/11/jruby-175-jre-6-stdin-bug</id>
    <content type="html"><![CDATA[<p>最近在jruby 1.7.5 + jre 6上碰到的土亢</p>

<h1>现象</h1>

<p>用backtick调用命令，比如</p>

<figure class='code'><figcaption><span>用backtick调用命令  </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="sb">`./some_script`</span>
</span></code></pre></td></tr></table></div></figure>


<p>在调用命令之前/同时在terminal输入一些回车，有一定概率backtick的调用会卡住不返回。
此时再输入一个回车，调用会继续执行并返回。</p>

<h1>解决</h1>

<p>一切靠猜</p>

<p>jruby有个bug：<a href="http://jira.codehaus.org/browse/JRUBY-4626">Gaps in STDIN pipe stream if backtick is used</a></p>

<p>Charles Oliver Nutter在comment中写到&#8221;For JRuby 1.7pre1 on Java 7, this should be fixed; TTY should be handled correctly. For other Java versions, we can&#8217;t fix this.&#8221;，于是最方便的就是升级jre到7</p>

<p>经验证升级jre可以从土亢中爬出来。
如果难以升级jre，参看<a href="https://www.ruby-forum.com/topic/4413754">这里</a>，这个兄弟做了很全的测试。可以用IO.popen或者Open3.popen3替换backtick。</p>

<h1>经验</h1>

<p>jruby有坑，同时也提供了便捷的手段将现有的java项目改成比较爽的样子。这些坑是难以预料的，做好准备，然后一如既往踩过去。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[mysql 5.6.15 replication中碰到的死锁]]></title>
    <link href="http://ikarishinjieva.github.com/blog/blog/2013/10/11/hole-in-mysql-56-replication-dead-lock/"/>
    <updated>2013-10-11T21:21:00+08:00</updated>
    <id>http://ikarishinjieva.github.com/blog/blog/2013/10/11/hole-in-mysql-56-replication-dead-lock</id>
    <content type="html"><![CDATA[<p>简述下今天在mysql 5.6.15上碰到的土亢</p>

<h1>现象</h1>

<p>mysql开启主从复制时，用meb（MySQL Enterprise Backup）做备份会卡住。同时在slave上show slave status也会卡住。</p>

<p>查看slave上show processlist，可以看到sql thread的状态为 &#8220;Waiting for commit lock&#8221;</p>

<h1>猜测</h1>

<p>无论是&#8221;SHOW ENGINE INNODB STATUS&#8221;还是&#8221;SHOW OPEN TABLES&#8221;都没有提供有用的信息，还是一切靠猜</p>

<p>夜观天象猜到mysql存在bug <a href="http://bugs.mysql.com/bug.php?id=70307">&#8220;Another deadlock on FLUSH TABLES WITH READ LOCK + SHOW SLAVE STATUS&#8221;</a></p>

<p>其中描述了sql thread开始执行了transaction，但是没有commit的间隙，在slave上FLUSH TABLES WITH READ LOCK，会出现死锁</p>

<p>于是猜测，如果meb恰好在slave上某个transaction commit之前做了FLUSH TABLES WITH READ LOCK，然后调用了与&#8221;SHOW SLAVE STATUS&#8221;类似的机制获取slave info，那么就会如bug所述卡住。然后mysql由于TABLE LOCk的存在，sql thread也就会卡住。</p>

<p>BTW：搜一下mysql bug库，会有一些描述类似的bug，其中70307描述最靠谱，且有详细的<a href="http://bugs.mysql.com/file.php?id=20542">重现步骤</a>，我也成功在mysql 5.6.15上重现了bug。</p>

<h1>结果</h1>

<p>实验后证明猜对了&#8230;</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[jruby重写java项目的一些总结]]></title>
    <link href="http://ikarishinjieva.github.com/blog/blog/2013/08/29/rewrite-project-into-ruby/"/>
    <updated>2013-08-29T21:22:00+08:00</updated>
    <id>http://ikarishinjieva.github.com/blog/blog/2013/08/29/rewrite-project-into-ruby</id>
    <content type="html"><![CDATA[<p>久不更新了，6月换了工作</p>

<p>最近将一个小项目从java迁移到了jruby，在此总结一下</p>

<h1>从结果开始</h1>

<p>1.代码量上的比较</p>

<table>
<thead>
<tr>
<th></th>
<th> *             </th>
<th> 纯Java项目     </th>
<th> Jruby项目    </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td> 主代码行数       </td>
<td> 4073          </td>
<td> 2689 - 454 |</td>
</tr>
<tr>
<td></td>
<td> 测试代码行数    </td>
<td> 1707          </td>
<td> 1485 - 319 |</td>
</tr>
</tbody>
</table>


<p>其中Jruby项目中有454行主代码和319行测试代码为新加功能</p>

<p>结论是在迁移了所有功能后，主代码量减少了45%+，测试代码比例从41%增加到52%，测试case数也增加</p>

<p>2.DSL</p>

<p>在迁移过程中，加入了一些DSL，让代码变得更可读，类似于</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">unless</span> <span class="n">can_load</span> <span class="n">local_node</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">from_file</span>
</span><span class='line'>  <span class="nb">load</span> <span class="n">local_node</span><span class="o">.</span><span class="n">config</span><span class="p">,</span> <span class="ss">:sip_ip</span>
</span><span class='line'>  <span class="n">cluster</span><span class="o">.</span><span class="n">join</span> <span class="n">local_node</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">sip_ip</span>
</span><span class='line'>  <span class="n">cluster</span><span class="o">.</span><span class="n">lock</span> <span class="s2">&quot;lock_config&quot;</span> <span class="k">do</span>
</span><span class='line'>      <span class="n">load_remote_global_config</span>
</span><span class='line'>      <span class="nb">load</span> <span class="n">local_node</span><span class="o">.</span><span class="n">config</span><span class="p">,</span> <span class="n">with</span><span class="p">(</span><span class="vi">@remote_global_config</span><span class="p">)</span>
</span><span class='line'>      <span class="n">dump</span> <span class="n">local_node</span><span class="o">.</span><span class="n">config</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">else</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果了所有符号，就变成稍微(!)可读的一篇描述</p>

<p>3.部署</p>

<p>jruby可以被编译成class，打成jar，跑在一切有jvm和jruby jar的地方。与现有java项目的融合不成问题，此次也是迁移了整个项目中的一部分，其他部分保留java</p>

<h1>一些细节</h1>

<p>1.代码量的减少</p>

<p>抛弃脚本语言的优势论不谈，实践中，代码量的明显减少来自于以下几个方面：</p>

<p>   1.1.调用命令行更方便，在纯java中调用命令行比较烦，即使封装半天也很不爽。代码量差别不是很大，主要是不爽</p>

<p>   1.2.闭包。java中传递闭包得靠实现匿名接口，冗长麻烦，影响函数的复用。（要不定义多个函数，要不到处new interface）</p>

<p>   1.3.mixin。奇怪的是我混入的往往不是特性，而是辅助函数&#8230; 尽管这种方法不正规，但对于小类来说非常实用。比较以下两段代码</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">class</span> <span class="nc">A</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">aaaa</span>
</span><span class='line'>      <span class="no">XxxUtils</span><span class="o">.</span><span class="n">blabla</span> <span class="o">.</span><span class="n">.</span><span class="o">.</span>
</span><span class='line'>      <span class="no">YyyHelper</span><span class="o">.</span><span class="n">blublu</span> <span class="o">.</span><span class="n">.</span><span class="o">.</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">class</span> <span class="nc">A</span>
</span><span class='line'>  <span class="kp">include</span> <span class="no">XxxUtils</span><span class="p">,</span> <span class="no">YyyHelper</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">aaaa</span>
</span><span class='line'>      <span class="n">blabla</span> <span class="o">.</span><span class="n">.</span><span class="o">.</span>
</span><span class='line'>      <span class="n">blublu</span> <span class="o">.</span><span class="n">.</span><span class="o">.</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>   如果你跟我一样厌恶到处都是Utils、Helper，又比较烦static import&#8230;</p>

<p>   &#8220;mixin太多很容易命名冲突引起问题&#8221;，不得不承认这个担心是对的，我爽我的，谁爱操心谁操心吧。顺便提一句，名空间冲突解决最好的方法还数node.js的。</p>

<p>   1.4.标准库。不得不承认，ruby标准库的人性化做的非常好，链调用能节省很多无用的代码</p>

<p>   1.5.rspec mock。以前用java尽量避免用mock framework，都是用继承注入，太费代码以至于自己都觉得烦（尽管有IDEA的自动代码折叠，还是觉得烦），到处都是注入点的代码也很乱。
   这是一个很难解决的平衡，如果每一段代码都是上下文封闭的，那么代码很容易测试，但处理输入输出需要大量工作，如果不是，那测试就需要mock。
   尝试了rspec mock后（我相信任何mock framework都一样），觉得还不错，目前还没有失控的主要原因是每次mock不超过两层。</p>

<p>   最后，&#8221;代码行数不是XXX标准&#8221;，是的，我只是减少了无用代码元素在项目中的分布</p>

<p>2.DSL/HSL(Human-specific language)</p>

<p>关于DSL的尝试还很初级，主要目的是读起来通顺，拘泥于以下几种形式：</p>

<p>   2.1.函数名alias。每次写代码的时候是不是纠结于用[].exist、[].exists，或者[].exists?。实践中都是先流畅的（！）写函数梗概，不纠结调用的函数是不是存在，爱怎么用怎么用吧，不存在就alias一下。一切以写作顺畅为目的。</p>

<p>   2.2.mixin。如前面提到的，mixin提供了忽略类名的偏门，可以写出一句流畅的人话，比如cp file，而不是FileUtils.cp file</p>

<p>   2.3.动词函数。比较array.collect和collect array，我喜欢后面那款。动词函数，让&#8221;宾.动&#8221;的OO非人话，转换成&#8221;动宾&#8221;的人话。当然除非你是古文爱好者</p>

<p>   2.4.&#8221;介词&#8221;空函数。就是些输出=输入的空函数，比如之前例中&#8221;unless can_load local_node.config.from_file&#8221;的can_load就是空函数，较之&#8221;unless local_node.config.load_from_file?&#8221;更有人味</p>

<p>   2.5.最后，以上几种形式都没有Domain-specific，而是Human-specific。关于DSL的尝试还没有深入到domain的阶段，先从让程序说人话开始</p>

<p>   2.6.难以否认的部分：像所有的城市规划一样，整洁的背后都会藏着付出代价的区域，DSL的背后也会有支持代码，初次读支持代码会发现他们怪异、畸形、目的非常不明确，配合用例才能读懂。
   如何更好的管理这部分付出牺牲的代码值得讨论</p>

<p>3.部署和测试</p>

<p>简单描述一下当前部署方案中的要点</p>

<p>   3.1.跑测试时不用编译，直接跑rb脚本。部署时才编译。可以节省测试时间。</p>

<p>   3.2.程序运行是用java -cp &#8230;/jruby.jar com.xxx.XXX。测试运行是用java -cp &#8230;/jruby.jar org.jruby.Main -S blabla</p>

<p>   3.3.GEM_HOME 和 GEM_PATH 指向特定folder，用上面的命令安装gem即可将gem安装到指向的folder</p>

<p>   3.4.编译用jrubyc，打jar包的脚本需要自己写</p>

<p>   PS: 写个简单的watchr脚本，可以让主文件和相应的测试文件保存时，自动跑相应的测试，非常省事</p>

<p>4.一些缺陷</p>

<p>不得不承认的缺陷还有很多</p>

<p>   4.1.不是所有项目能平滑接入jruby，之前的确碰到过jruby和EclipseLink的冲突，与boot classpath相关，具体原因不祥。建议迁移前先搭原型进行测试</p>

<p>   4.2.（这条来自于实践经验）HSL(Human-specific language) 不是能全面实现的，只能在程序里的一部分实现，而且随着代码量的增加，支持代码的维护估计会显得吃力。（但是写起来的确很爽）</p>

<p>   4.3.改进后的代码也不是完全可读，难以忽略一些语言元素，也没法忽略业务背景</p>

<p>   4.4.写单元测试吧，懒不是个办法&#8230;</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[有意思的javascript笔误]]></title>
    <link href="http://ikarishinjieva.github.com/blog/blog/2013/05/28/interesting-js/"/>
    <updated>2013-05-28T22:33:00+08:00</updated>
    <id>http://ikarishinjieva.github.com/blog/blog/2013/05/28/interesting-js</id>
    <content type="html"><![CDATA[<p>前两天被拉去查一个很怪的错，描述是“一个js文件压缩前和压缩后执行结果不一样”</p>

<p>查了很久锁定以下代码</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'>   <span class="nx">s</span> <span class="o">=</span> <span class="nx">s</span> <span class="o">+</span> <span class="o">+</span><span class="p">(</span><span class="s2">&quot;...&quot;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>一看就是笔误了，压缩后为</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'>   <span class="nx">s</span><span class="o">=</span><span class="nx">s</span><span class="o">++</span><span class="p">(</span><span class="s2">&quot;...&quot;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>空格被压缩后显然会抛语法错。但没压缩能正常运行就有点意思了，做了以下尝试</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="o">+</span><span class="p">(</span><span class="s1">&#39;...&#39;</span><span class="p">)</span>
</span><span class='line'><span class="o">&gt;</span> <span class="kc">NaN</span>
</span><span class='line'><span class="o">-</span><span class="p">(</span><span class="s1">&#39;...&#39;</span><span class="p">)</span>
</span><span class='line'><span class="o">&gt;</span> <span class="kc">NaN</span>
</span><span class='line'><span class="s1">&#39;1&#39;</span> <span class="o">+</span> <span class="o">+</span><span class="p">(</span><span class="s1">&#39;...&#39;</span><span class="p">)</span>
</span><span class='line'><span class="o">&gt;</span> <span class="s2">&quot;1NaN&quot;</span>
</span><span class='line'><span class="o">+</span><span class="p">(</span><span class="kc">NaN</span><span class="p">)</span>
</span><span class='line'><span class="o">&gt;</span> <span class="kc">NaN</span>
</span></code></pre></td></tr></table></div></figure>


<p>那个多出来的加号，被解释成取数字正值，就像减号在数字前是取数字的负值一样。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java off-heap的一些参考]]></title>
    <link href="http://ikarishinjieva.github.com/blog/blog/2013/05/18/java-offheap-memory/"/>
    <updated>2013-05-18T23:00:00+08:00</updated>
    <id>http://ikarishinjieva.github.com/blog/blog/2013/05/18/java-offheap-memory</id>
    <content type="html"><![CDATA[<p>读了Hazelcast的文档，很有意思的部分是&#8221;Elastic Memory&#8221;，为了减少GC，用到了java off-heap(off-heap允许Java直接操作内存空间, 类似于C的malloc和free)。之前孤陋寡闻，记录一些off-heap的参考。</p>

<p>1.做了以下对比试验，来对比Heap和Non-heap</p>

<figure class='code'><figcaption><span>Heap  </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">HeapAllocation</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">Integer</span><span class="o">[]</span> <span class="n">a</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Integer</span><span class="o">[</span><span class="mi">1000000</span><span class="o">];</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span>Off-heap  </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kn">import</span> <span class="nn">java.lang.reflect.Field</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">OffHeapAllocation</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">static</span> <span class="n">Unsafe</span> <span class="n">unsafe</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">static</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">try</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">Field</span> <span class="n">field</span> <span class="o">=</span> <span class="n">Unsafe</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getDeclaredField</span><span class="o">(</span><span class="s">&quot;theUnsafe&quot;</span><span class="o">);</span>
</span><span class='line'>            <span class="n">field</span><span class="o">.</span><span class="na">setAccessible</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
</span><span class='line'>            <span class="n">unsafe</span> <span class="o">=</span> <span class="o">(</span><span class="n">Unsafe</span><span class="o">)</span><span class="n">field</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="kc">null</span><span class="o">);</span>
</span><span class='line'>        <span class="o">}</span> <span class="k">catch</span><span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="kt">long</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">unsafe</span><span class="o">.</span><span class="na">allocateMemory</span><span class="o">(</span><span class="mi">8</span> <span class="o">*</span> <span class="mi">1000000</span><span class="o">);</span>
</span><span class='line'>            <span class="n">unsafe</span><span class="o">.</span><span class="na">freeMemory</span><span class="o">(</span><span class="n">addr</span><span class="o">);</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Heap GC的测试结果：
<img src="http://ikarishinjieva.github.com/blog/images/2013-05-18-java-offheap-memory-0.png" title="Heap" ></p>

<p>Off-heap GC的测试结果：
<img src="http://ikarishinjieva.github.com/blog/images/2013-05-18-java-offheap-memory-1.png" title="Off-heap" ></p>

<p>尽管这种测试没啥意义，只能给个直观感受，还是可以看到Heap GC Pause Time还是很多的。</p>

<p>2.<a href="http://mentablog.soliveirajr.com/2012/11/which-one-is-faster-java-heap-or-native-memory">这篇文章</a> 对off-heap的性能做了全面的对比。</p>

<p>结论是heap access要快于off-heap，但off-heap在躲开GC pause和开大内存的时候明显优秀。</p>

<p>有趣的是在评论一楼Peter Lawrey指出JIT会影响这个测试，于是作者重做测试以证明JIT不影响结论。</p>

<p>3.<a href="http://mentablog.soliveirajr.com/2012/11/real-time-java-programming-without-gc">这篇文章</a> 讨论了如何让Java避开GC并提供了memory的测试类GCUtils。</p>

<p>4.<a href="http://stackoverflow.com/questions/12246533/where-to-find-the-evidence-of-how-to-calculate-the-size-of-a-java-object">在这里</a> Peter Lawrey谈到了如何测量一个Java对象的大小和TLAB对测量的影响。仅供参考。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[实验：Mysql master-slave-standby将source从master切换到standby]]></title>
    <link href="http://ikarishinjieva.github.com/blog/blog/2013/05/15/mysql-master-slave-standby-failover/"/>
    <updated>2013-05-15T22:40:00+08:00</updated>
    <id>http://ikarishinjieva.github.com/blog/blog/2013/05/15/mysql-master-slave-standby-failover</id>
    <content type="html"><![CDATA[<p>尝试了&lt;Mysql High Availability&gt;第四章热备份一节的实验,记录步骤.</p>

<p>先统一原语,master/slave/standby表示三台机器名,source/target代表replication关系的两端（不适用master/slave用以和机器名区分）.&#8221;master(3)&#8221;表示master机器的db里有三条数据1,2,3.</p>

<p>实验开始.</p>

<ol>
<li>初始状态是存在master->slave, master->standby的replication</li>
<li>standby在切换成source时,需要有bin-log和replication user. 在此重新设置master->standby的replication, 让standby满足要求.</li>
</ol>


<p>忽略replication user的部分.</p>

<p>bin-log的部分在my.cnf里要设置log-bin和log-slave-updates(默认情况下,master->standby的replication不会写standby的bin-log,需开始standby的log-slave-updates才会写).</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>server-id               = 3
</span><span class='line'>log_bin                 = /var/log/mysql/mysql-bin.log
</span><span class='line'>...
</span><span class='line'>relay-log-index         = /var/log/mysql/slave-relay-bin.index
</span><span class='line'>relay-log               = /var/log/mysql/slave-relay-bin
</span><span class='line'>log-slave-updates</span></code></pre></td></tr></table></div></figure>


<ol>
<li>测试一下standby binlog设置成功。可以在master插入一条数据，在standby查看</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>standby> show binlog events;
</span><span class='line'>+------------------+------+-------------+-----------+-------------+------------------------------------------------------------------------+
</span><span class='line'>| Log_name         | Pos  | Event_type  | Server_id | End_log_pos | Info                                                                   |
</span><span class='line'>+------------------+------+-------------+-----------+-------------+------------------------------------------------------------------------+
</span><span class='line'>| mysql-bin.000001 |    4 | Format_desc |         3 |         107 | Server ver: 5.5.31-0ubuntu0.12.04.1-log, Binlog ver: 4                 |
</span><span class='line'>| mysql-bin.000001 |  107 | Query       |         1 |         166 | BEGIN                                                                  |
</span><span class='line'>| mysql-bin.000001 |  166 | Query       |         1 |         257 | use `tac`; insert into test values(8889)                               |
</span><span class='line'>| mysql-bin.000001 |  257 | Xid         |         1 |         284 | COMMIT /* xid=111 */    
</span><span class='line'>...</span></code></pre></td></tr></table></div></figure>


<ol>
<li>将replication调整至状态master(3),standby(2),slave(1). 人工造成各db的状态不一致</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>master> insert into test values(1);
</span><span class='line'>slave> stop slave;
</span><span class='line'>master> insert into test values(2);
</span><span class='line'>standby> stop slave;
</span><span class='line'>master> insert into test values(3);</span></code></pre></td></tr></table></div></figure>


<ol>
<li><p>想象此时master挂掉,开始将source从master切换成standby</p></li>
<li><p>在建立standby->slave的replication之前，需要将standby和slave数据同步(此时slave落后于standby)。</p></li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>-- 先查看standby从master拿了多少数据
</span><span class='line'>standby> show slave status \G
</span><span class='line'>*************************** 1. row ***************************
</span><span class='line'>...
</span><span class='line'>        Master_Log_File: master-bin.000023
</span><span class='line'>...
</span><span class='line'>        Exec_Master_Log_Pos: 1391
</span><span class='line'>        
</span><span class='line'>-- 让slave从master上同步到跟standby同样的位置
</span><span class='line'>slave> start slave until master_log_file = 'master-bin.000023', master_log_pos = 1391;</span></code></pre></td></tr></table></div></figure>


<p>有意思的是此处用了master(其实我们假设master已经坏了&#8230;)。</p>

<ol>
<li>此时可以讲slave的source从master切换到standby. 一个问题就是standby->slave的开始位置可能是和master->slave不同</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>-- 查看standby binlog的当前位置
</span><span class='line'>mysql> show master status \G
</span><span class='line'>*************************** 1. row ***************************
</span><span class='line'>    File: mysql-bin.000001 
</span><span class='line'>    Position: 796
</span><span class='line'>    Binlog_Do_DB:
</span><span class='line'>  Binlog_Ignore_DB:
</span><span class='line'>-- 注意与master上的文件名和位置都不同
</span><span class='line'>
</span><span class='line'>-- 切换slave的source
</span><span class='line'>slave> change master to 
</span><span class='line'>            master_host = '192.168.50.4', 
</span><span class='line'>            master_port = 3306, 
</span><span class='line'>            master_user = 'repl', 
</span><span class='line'>            master_password = 'repl', 
</span><span class='line'>            master_log_file = 'mysql-bin.000001', 
</span><span class='line'>            master_log_pos = 796;</span></code></pre></td></tr></table></div></figure>


<ol>
<li>测试一下standby->slave replication.</li>
</ol>


<p>总的思路就是讲master(3),standby(2),slave(1)同步成master(3),standby(2),slave(2),然后将master->slave切换成standby->slave.</p>

<p>遗留了两个问题,其一是slave和standby同步时使用了&#8221;坏掉&#8221;的master;其二是master超前了standby和slave, 也就是standby->slave丢失了master的超前数据。留待慢慢学习。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于Mysql binlog的一点学习]]></title>
    <link href="http://ikarishinjieva.github.com/blog/blog/2013/05/12/mysql-binlog-study/"/>
    <updated>2013-05-12T22:59:00+08:00</updated>
    <id>http://ikarishinjieva.github.com/blog/blog/2013/05/12/mysql-binlog-study</id>
    <content type="html"><![CDATA[<p>差不多一个月没更新了。除了忙些琐事，就是偷点懒。</p>

<p>在读&lt;Mysql High Availability&gt;，扫了一遍，读第二遍的时候开始做些实验，所以这之后的blog写的也会没什么章法。</p>

<p>&lt;Mysql High Availability&gt;第三章介绍binlog时特地提到了Rand()/Now()/User variable/Password()在基于sql复制时的行为，简单做些实验。</p>

<ol>
<li>Rand()</li>
</ol>


<p>Rand() 在replication中，值会被正确传递。如下查看binlog，发现pos 209处rand_seed会被传给slave，保证rand生成的值保持一致。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>mysql> show binlog events in 'master-bin.000007';
</span><span class='line'>+-------------------+-----+-------------+-----------+-------------+--------------------------------------------------------+
</span><span class='line'>| Log_name          | Pos | Event_type  | Server_id | End_log_pos | Info                                                   |
</span><span class='line'>+-------------------+-----+-------------+-----------+-------------+--------------------------------------------------------+
</span><span class='line'>| master-bin.000007 |   4 | Format_desc |         1 |         107 | Server ver: 5.5.31-0ubuntu0.12.04.1-log, Binlog ver: 4 |
</span><span class='line'>| master-bin.000007 | 107 | Query       |         1 |         174 | BEGIN                                                  |
</span><span class='line'>| master-bin.000007 | 174 | RAND        |         1 |         209 | rand_seed1=598597315,rand_seed2=24268577               |
</span><span class='line'>| master-bin.000007 | 209 | Query       |         1 |         302 | use `tac`; insert into test values(rand())             |
</span><span class='line'>| master-bin.000007 | 302 | Xid         |         1 |         329 | COMMIT /* xid=151 */                                   |
</span><span class='line'>+-------------------+-----+-------------+-----------+-------------+--------------------------------------------------------+</span></code></pre></td></tr></table></div></figure>


<ol>
<li>Now()</li>
</ol>


<p>Now() 在replication中，值会被正确传递。如下查看binlog，pos 283处，貌似这个语句传给slave，会由于master和slave的时间不同步，导致问题。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>master> flush logs;
</span><span class='line'>     master> SET TIMESTAMP=unix_timestamp('2010-10-01 12:00:00');
</span><span class='line'>     master> insert into test values(now());
</span><span class='line'>     master> show binlog events in 'master-bin.000007';
</span><span class='line'>
</span><span class='line'>+-------------------+-----+-------------+-----------+-------------+--------------------------------------------------------+
</span><span class='line'>| Log_name          | Pos | Event_type  | Server_id | End_log_pos | Info                                                   |
</span><span class='line'>+-------------------+-----+-------------+-----------+-------------+--------------------------------------------------------+
</span><span class='line'>| master-bin.000012 |   4 | Format_desc |         1 |         107 | Server ver: 5.5.31-0ubuntu0.12.04.1-log, Binlog ver: 4 |
</span><span class='line'>| master-bin.000012 | 107 | Query       |         1 |         182 | BEGIN                                                  |
</span><span class='line'>| master-bin.000012 | 182 | Query       |         1 |         283 | use `tac`; insert into test values (now())             |
</span><span class='line'>| master-bin.000012 | 283 | Xid         |         1 |         310 | COMMIT /* xid=131 */                                   |
</span><span class='line'>+-------------------+-----+-------------+-----------+-------------+--------------------------------------------------------+</span></code></pre></td></tr></table></div></figure>


<p>但通过mysqladmin查看binlog，可以看到binlog中会不断插入TIMESTAMP来保证now()函数的执行结果在master和slave是相同的。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>master> sudo mysqlbinlog --short-form master-bin.000017
</span><span class='line'>... 
</span><span class='line'>DELIMITER /*!*/;
</span><span class='line'>SET TIMESTAMP=1285934400/*!*/;
</span><span class='line'>...
</span><span class='line'>BEGIN
</span><span class='line'>/*!*/;
</span><span class='line'>use `tac`/*!*/;
</span><span class='line'>SET TIMESTAMP=1285934400/*!*/;
</span><span class='line'>insert into test values(now())
</span><span class='line'>/*!*/;
</span><span class='line'>COMMIT/*!*/;
</span><span class='line'>SET TIMESTAMP=1368372377/*!*/;
</span><span class='line'>BEGIN
</span><span class='line'>/*!*/;
</span><span class='line'>SET TIMESTAMP=1368372377/*!*/;
</span><span class='line'>insert into test values(now())
</span><span class='line'>/*!*/;
</span><span class='line'>COMMIT/*!*/;
</span><span class='line'>...</span></code></pre></td></tr></table></div></figure>


<ol>
<li>User variable</li>
</ol>


<p>User variable会被编码成十六进制串，含义不明，保密性不明。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>mysql> flush logs;
</span><span class='line'>Query OK, 0 rows affected (0.02 sec)
</span><span class='line'>
</span><span class='line'>mysql> set @foo = now();
</span><span class='line'>Query OK, 0 rows affected (0.00 sec)
</span><span class='line'>
</span><span class='line'>mysql> insert into test values (@foo);
</span><span class='line'>Query OK, 1 row affected (0.01 sec)
</span><span class='line'>
</span><span class='line'>mysql> show binlog events in 'master-bin.000014';
</span><span class='line'>+-------------------+-----+-------------+-----------+-------------+-----------------------------------------------------------------------------------+
</span><span class='line'>| Log_name          | Pos | Event_type  | Server_id | End_log_pos | Info                                                                              |
</span><span class='line'>+-------------------+-----+-------------+-----------+-------------+-----------------------------------------------------------------------------------+
</span><span class='line'>| master-bin.000014 |   4 | Format_desc |         1 |         107 | Server ver: 5.5.31-0ubuntu0.12.04.1-log, Binlog ver: 4                            |
</span><span class='line'>| master-bin.000014 | 107 | Query       |         1 |         174 | BEGIN                                                                             |
</span><span class='line'>| master-bin.000014 | 174 | User var    |         1 |         229 | @`foo`=_latin1 0x323031302D31302D30312031323A30303A3030 COLLATE latin1_swedish_ci |
</span><span class='line'>| master-bin.000014 | 229 | Query       |         1 |         321 | use `tac`; insert into test values (@foo)                                         |
</span><span class='line'>| master-bin.000014 | 321 | Xid         |         1 |         348 | COMMIT /* xid=148 */                                                              |
</span><span class='line'>+-------------------+-----+-------------+-----------+-------------+-----------------------------------------------------------------------------------+
</span><span class='line'>5 rows in set (0.00 sec)</span></code></pre></td></tr></table></div></figure>


<ol>
<li>Password()</li>
</ol>


<p>直接内嵌使用password，会在binlog里暴露密码，就像下面的测试。可以使用user variable,但是不知道user variable的编码保密性如何。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>mysql> insert into test values(password('tac'));
</span><span class='line'>mysql> show binlog events in 'master-bin.000015';
</span><span class='line'>+-------------------+-----+-------------+-----------+-------------+--------------------------------------------------------+
</span><span class='line'>| Log_name          | Pos | Event_type  | Server_id | End_log_pos | Info                                                   |
</span><span class='line'>+-------------------+-----+-------------+-----------+-------------+--------------------------------------------------------+
</span><span class='line'>| master-bin.000015 |   4 | Format_desc |         1 |         107 | Server ver: 5.5.31-0ubuntu0.12.04.1-log, Binlog ver: 4 |
</span><span class='line'>| master-bin.000015 | 107 | Query       |         1 |         174 | BEGIN                                                  |
</span><span class='line'>| master-bin.000015 | 174 | Query       |         1 |         276 | use `tac`; insert into test values(password('tac'))    |
</span><span class='line'>| master-bin.000015 | 276 | Xid         |         1 |         303 | COMMIT /* xid=158 */                                   |
</span><span class='line'>+-------------------+-----+-------------+-----------+-------------+--------------------------------------------------------+
</span><span class='line'>4 rows in set (0.01 sec)</span></code></pre></td></tr></table></div></figure>


<p>简单一点学习如上。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[lisp一个大写的坑]]></title>
    <link href="http://ikarishinjieva.github.com/blog/blog/2013/04/16/lisp-symbol-upper-case/"/>
    <updated>2013-04-16T23:12:00+08:00</updated>
    <id>http://ikarishinjieva.github.com/blog/blog/2013/04/16/lisp-symbol-upper-case</id>
    <content type="html"><![CDATA[<p>最近一直掉在一个坑里，今天刚出坑</p>

<p>想用宏定义不同的函数，类似于:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(defmacro macro (name)
</span><span class='line'>     `(defmethod ,(intern (format nil "set-~a" name)) ()))</span></code></pre></td></tr></table></div></figure>


<p>跑(macro test)，结果就是</p>

<figure class='code'><figcaption><span>函数名是&#8221;|set-TEST|&#8221;，而不是需要的&#8221;set-test&#8221;</span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#&lt;STANDARD-METHOD |set-TEST| NIL></span></code></pre></td></tr></table></div></figure>


<p>几天的困惑以后（尝试换过lisp的实现去测试），找到了<a href="http://www.cs.rochester.edu/~schubert/247-447/symbols-in-lisp.html">这篇文章</a>，发现是符号名大小写引起的问题</p>

<figure class='code'><figcaption><span>简单测试一下</span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>CL-USER> (eq (intern "test") 'test)
</span><span class='line'>NIL
</span><span class='line'>CL-USER> (intern "test")
</span><span class='line'>|test|
</span><span class='line'>:INTERNAL
</span><span class='line'>CL-USER> (eq (intern "TEST") 'test)
</span><span class='line'>T
</span><span class='line'>CL-USER> (intern "TEST")
</span><span class='line'>TEST
</span><span class='line'>:INTERNAL</span></code></pre></td></tr></table></div></figure>


<p>大小写通过intern生成的符号是不一样的，全大写才会生成正确的符号。</p>

<p>参考：</p>

<p><a href="http://www.cs.rochester.edu/~schubert/247-447/symbols-in-lisp.html">How to handle symbols in LISP</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[我写了半辈子程序 & java的重载方法选择基于编译期参数类型]]></title>
    <link href="http://ikarishinjieva.github.com/blog/blog/2013/03/31/java-method-passing/"/>
    <updated>2013-03-31T23:22:00+08:00</updated>
    <id>http://ikarishinjieva.github.com/blog/blog/2013/03/31/java-method-passing</id>
    <content type="html"><![CDATA[<p>一段时间没更新过blog,因为花了些时间在读lisp的入门,还将继续一段时间</p>

<p>先庆祝下自己25岁,可以正式对外宣称&#8221;我写了半辈子程序&#8221;</p>

<p>读lisp的入门时,有一个java的对比例子觉得很有意思(虽然事后想想也就那么回事)&#8230;</p>

<p>简单的说,一个call传递给object(根据运行时的类型找到需要处理这个call的类),并找到对应的方法(根据call参数的编译时类型,找到需要处理这个call的函数),并执行</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">A</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">foo</span><span class="o">(</span><span class="n">A</span> <span class="n">a</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;A/A&quot;</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">foo</span><span class="o">(</span><span class="n">B</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;A/B&quot;</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">B</span> <span class="kd">extends</span> <span class="n">A</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">foo</span><span class="o">(</span><span class="n">A</span> <span class="n">a</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;B/A&quot;</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">foo</span><span class="o">(</span><span class="n">B</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;B/B&quot;</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">C</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">params</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'><span class="c1">//        A obj = new A();</span>
</span><span class='line'>        <span class="n">A</span> <span class="n">obj</span> <span class="o">=</span> <span class="k">new</span> <span class="n">B</span><span class="o">();</span>
</span><span class='line'>        <span class="n">obj</span><span class="o">.</span><span class="na">foo</span><span class="o">(</span><span class="n">obj</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>运行结果是&#8221;B/A&#8221;,B这个类是根据运行类型找到的,foo(A)这个方法是根据编译类型找到的。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[读了“There is no simple solution for local storage”]]></title>
    <link href="http://ikarishinjieva.github.com/blog/blog/2013/03/19/some-readings-about-localStorage/"/>
    <updated>2013-03-19T23:35:00+08:00</updated>
    <id>http://ikarishinjieva.github.com/blog/blog/2013/03/19/some-readings-about-localStorage</id>
    <content type="html"><![CDATA[<p>作为一个非专职Client开发,偶然读了读关于localStorage的<a href="http://www.36ria.com/6075">这篇有趣的文字</a>,非常有意思,引文也很值得一读。</p>

<p>作者的思考方向很全面。摘取其中重要的部分：</p>

<ol>
<li><p>(性能) localStorage是会阻止渲染(同步),会写I/O</p></li>
<li><p>(浏览器行为) localStorage会被浏览器预载入,会被永久存储,浏览器支持良好</p></li>
<li><p>(开发接口) 接口简单。缺少getSize这样的接口</p></li>
<li><p>(用户接口) 用户授权简单</p></li>
</ol>


<p>解决localStorage问题的方案,可能是升级或者寻找替代品,衡量的方向也是上面几点。</p>

<p>值得一读的引文：</p>

<p><a href="http://htmlui.com/blog/2011-08-23-5-obscure-facts-about-html5-localstorage.html">这篇引文</a> 描述了LocalStorage的几个限制。值得注意的是http和https的localStorage不能互通。</p>

<p><a href="https://hacks.mozilla.org/2012/02/saving-images-and-files-in-localstorage/">Saving images and files in localStorage</a></p>
]]></content>
  </entry>
  
</feed>
