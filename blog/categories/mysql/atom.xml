<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: mysql | Tac say]]></title>
  <link href="http://ikarishinjieva.github.com/blog/blog/categories/mysql/atom.xml" rel="self"/>
  <link href="http://ikarishinjieva.github.com/blog/"/>
  <updated>2014-06-15T11:23:47+08:00</updated>
  <id>http://ikarishinjieva.github.com/blog/</id>
  <author>
    <name><![CDATA[Tac Huang (ikari_shinji@github)]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[测试Mysql临时表的复制]]></title>
    <link href="http://ikarishinjieva.github.com/blog/blog/2014/06/12/temporary-table-replication/"/>
    <updated>2014-06-12T22:32:00+08:00</updated>
    <id>http://ikarishinjieva.github.com/blog/blog/2014/06/12/temporary-table-replication</id>
    <content type="html"><![CDATA[<p>测试一下Mysql 5.6.17对临时表的复制</p>

<h4>参考资料</h4>

<ol>
<li>Percona这篇08年的blog <a href="http://www.mysqlperformanceblog.com/2008/05/26/mysql-temporary-tables-safe-for-statement-based-replication/">Can MySQL temporary tables be made safe for statement-based replication?</a>, 是对于Mysql 5.1这方面的测试. 但根据对Mysql 5.6的相关测试, 其结论已经不适用. 其方法可供参考</li>
<li><p>Mysql Manual 对于临时表复制的<a href="http://dev.mysql.com/doc/refman/5.6/en/replication-features-temptables.html">讨论</a>, 其中一些重要的描述列在下面:</p></li>
<li><p>Safe slave shutdown when using temporary tables</p></li>
<li>By default, all temporary tables are replicated; this happens whether or not there are any matching <code>--replicate-do-db</code>, <code>--replicate-do-table</code>, or <code>--replicate-wild-do-table</code> options in effect</li>
<li>the <code>--replicate-ignore-table</code> and <code>--replicate-wild-ignore-table</code> options are honored for temporary tables</li>
</ol>


<h4>概述</h4>

<p>总共做了两个测试:</p>

<ol>
<li>Mysql Manual中"Safe slave shutdown when using temporary tables"一节, 验证为何需要如此安全关闭slave</li>
<li>验证在复制临时表时, master意外crash, 是否会造成slave上的资源泄露</li>
</ol>


<p>每个测试后都有结论</p>

<h4>测试一</h4>

<p>针对Mysql Manual提到的"Safe slave shutdown when using temporary tables", 重现一下:</p>

<p>```</p>

<h1>准备环境, 断开复制</h1>

<p>mysql-master> select @@binlog_format;
+-----------------+
| @@binlog_format |
+-----------------+
| MIXED           |
+-----------------+
1 row in set (0.02 sec)</p>

<p>mysql-slave> stop slave;
Query OK, 0 rows affected (0.03 sec)
```</p>

<p>```</p>

<h1>在master上构造使用临时表的两个transaction</h1>

<p>mysql-master> flush logs;
Query OK, 0 rows affected (0.02 sec)</p>

<p>mysql-master> begin;
Query OK, 0 rows affected (0.00 sec)</p>

<p>mysql-master> create temporary table test.t(t int);
Query OK, 0 rows affected (0.01 sec)</p>

<p>mysql-master> commit;
Query OK, 0 rows affected (0.00 sec)</p>

<p>mysql-master> begin;
Query OK, 0 rows affected (0.00 sec)</p>

<p>mysql-master> insert into test.a select t from test.t;
Query OK, 0 rows affected (0.00 sec)
Records: 0  Duplicates: 0  Warnings: 0</p>

<p>mysql-master> commit;
Query OK, 0 rows affected (0.00 sec)
```</p>

<p>```</p>

<h1>查看master的binlog</h1>

<p>mysql-master> show binlog events in "mysql-bin.000036" \G
<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><em> 1. row </em></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>
   Log_name: mysql-bin.000036</p>

<pre><code>    Pos: 4
</code></pre>

<p> Event_type: Format_desc
  Server_id: 1
End_log_pos: 120</p>

<pre><code>   Info: Server ver: 5.6.17-debug-log, Binlog ver: 4
</code></pre>

<p><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><em> 2. row </em></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>
   Log_name: mysql-bin.000036</p>

<pre><code>    Pos: 120
</code></pre>

<p> Event_type: Query
  Server_id: 1
End_log_pos: 195</p>

<pre><code>   Info: BEGIN
</code></pre>

<p><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><em> 3. row </em></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>
   Log_name: mysql-bin.000036</p>

<pre><code>    Pos: 195
</code></pre>

<p> Event_type: Query
  Server_id: 1
End_log_pos: 301</p>

<pre><code>   Info: create temporary table test.t(t int)
</code></pre>

<p><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><em> 4. row </em></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>
   Log_name: mysql-bin.000036</p>

<pre><code>    Pos: 301
</code></pre>

<p> Event_type: Query
  Server_id: 1
End_log_pos: 370</p>

<pre><code>   Info: COMMIT
</code></pre>

<p><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><em> 5. row </em></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>
   Log_name: mysql-bin.000036</p>

<pre><code>    Pos: 370
</code></pre>

<p> Event_type: Query
  Server_id: 1
End_log_pos: 445</p>

<pre><code>   Info: BEGIN
</code></pre>

<p><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><em> 6. row </em></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>
   Log_name: mysql-bin.000036</p>

<pre><code>    Pos: 445
</code></pre>

<p> Event_type: Query
  Server_id: 1
End_log_pos: 554</p>

<pre><code>   Info: insert into test.a select t from test.t
</code></pre>

<p><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><em> 7. row </em></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>
   Log_name: mysql-bin.000036</p>

<pre><code>    Pos: 554
</code></pre>

<p> Event_type: Query
  Server_id: 1
End_log_pos: 623</p>

<pre><code>   Info: COMMIT
</code></pre>

<p>7 rows in set (0.00 sec)
```</p>

<p>```</p>

<h1>开启复制,让复制在两个transaction之间中断</h1>

<p>mysql-slave> start slave until master_log_file='mysql-bin.000036', master_log_pos=370;
Query OK, 0 rows affected, 1 warning (0.02 sec)</p>

<p>mysql-slave> show slave status\G
<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><em> 1. row </em></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></p>

<pre><code>           Slave_IO_State: Waiting for master to send event
</code></pre>

<p>...</p>

<pre><code>          Master_Log_File: mysql-bin.000036
      Read_Master_Log_Pos: 623
</code></pre>

<p>...</p>

<pre><code>    Relay_Master_Log_File: mysql-bin.000036
         Slave_IO_Running: Yes
        Slave_SQL_Running: No
</code></pre>

<p>...</p>

<pre><code>      Exec_Master_Log_Pos: 370
</code></pre>

<p>...
1 row in set (0.00 sec)</p>

<p>```</p>

<p>```</p>

<h1>查看slave正在使用的临时表, 并重启slave</h1>

<p>mysql-slave> show status like '%temp%';                    <br/>
+------------------------+-------+
| Variable_name          | Value |
+------------------------+-------+
| Slave_open_temp_tables | 1     |
+------------------------+-------+
1 row in set (0.01 sec)</p>

<p>slave> service mysqld restart
```</p>

<p>```</p>

<h1>验证slave status</h1>

<p>mysql-slave> show slave status\G
<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><em> 1. row </em></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>
...</p>

<pre><code>          Master_Log_File: mysql-bin.000036
      Read_Master_Log_Pos: 623
</code></pre>

<p>...</p>

<pre><code>    Relay_Master_Log_File: mysql-bin.000036
         Slave_IO_Running: Yes
        Slave_SQL_Running: No
</code></pre>

<p>...</p>

<pre><code>               Last_Errno: 1146
               Last_Error: Error 'Table 'test.t' doesn't exist' on query. Default database: ''. Query: 'insert into test.a select t from test.t'
</code></pre>

<p>...</p>

<pre><code>      Exec_Master_Log_Pos: 370
</code></pre>

<p>...</p>

<pre><code>           Last_SQL_Errno: 1146
           Last_SQL_Error: Error 'Table 'test.t' doesn't exist' on query. Default database: ''. Query: 'insert into test.a select t from test.t'
</code></pre>

<p>  Replicate_Ignore_Server_Ids:
...
1 row in set (0.00 sec)</p>

<p>```</p>

<p><strong>结论</strong>: 使用临时表时, slave并不保证crash-safe, 而且若在连续的transaction中复用同一个临时表, 完全没办法安全修复.</p>

<h4>测试2</h4>

<p>对于一个<code>create temporary table</code>, 已知<code>drop temporary table</code>会在session结束时写进binlog. 那么如果master意外退出, 是不是会对slave造成资源泄露? 比如不释放文件句柄</p>

<p>```</p>

<h1>准备master环境</h1>

<p>mysql-master> select @@binlog_format;
+-----------------+
| @@binlog_format |
+-----------------+
| MIXED           |
+-----------------+
1 row in set (0.00 sec)</p>

<p>mysql-master> select @@gtid_mode;
+-------------+
| @@gtid_mode |
+-------------+
| OFF         |
+-------------+
1 row in set (0.00 sec)
```</p>

<p>```</p>

<h1>检查slave上的资源</h1>

<p>mysql-slave> show status like '%open%';
+----------------------------+-------+
| Variable_name              | Value |
+----------------------------+-------+
...
| Innodb_num_open_files      | 6     |
| Open_files                 | 22    |
| Open_streams               | 0     |
| Open_table_definitions     | 70    |
| Open_tables                | 63    |
| Opened_files               | 164   |
| Opened_table_definitions   | 0     |
| Opened_tables              | 0     |
| Slave_open_temp_tables     | 0     |
...
+----------------------------+-------+
14 rows in set (0.00 sec)
```</p>

<p>```</p>

<h1>在master上创建5张临时表</h1>

<p>mysql-master> create temporary table test.t1 (t int);create temporary table test.t2 (t int);create temporary table test.t3 (t int);create temporary table test.t4 (t int);create temporary table test.t5 (t int);
Query OK, 0 rows affected (0.02 sec)</p>

<p>Query OK, 0 rows affected (0.00 sec)</p>

<p>Query OK, 0 rows affected (0.01 sec)</p>

<p>Query OK, 0 rows affected (0.01 sec)</p>

<p>Query OK, 0 rows affected (0.01 sec)</p>

<p>```</p>

<p>```</p>

<h1>检查slave上的资源</h1>

<p>mysql-slave> show status like '%open%';
+----------------------------+-------+
| Variable_name              | Value |
+----------------------------+-------+
...
| Innodb_num_open_files      | 11    |
| Open_files                 | 22    |
| Open_streams               | 0     |
| Open_table_definitions     | 70    |
| Open_tables                | 63    |
| Opened_files               | 179   |
| Opened_table_definitions   | 0     |
| Opened_tables              | 0     |
| Slave_open_temp_tables     | 5     |
...
+----------------------------+-------+
14 rows in set (0.00 sec)
```</p>

<p>```</p>

<h1>引发master故障, 重启master库</h1>

<p>master> pkill -9 mysqld
master> /opt/mysql/bin/mysqld_safe &amp;
```</p>

<p>```</p>

<h1>重启slave复制, 检查slave上的资源</h1>

<p>mysql-slave> stop slave io_thread;
Query OK, 0 rows affected (0.02 sec)</p>

<p>mysql-slave> start slave io_thread;
Query OK, 0 rows affected (0.00 sec)</p>

<p>mysql-slave> show status like '%open%';
+----------------------------+-------+
| Variable_name              | Value |
+----------------------------+-------+
...
| Innodb_num_open_files      | 6     |
| Open_files                 | 22    |
| Open_streams               | 0     |
| Open_table_definitions     | 70    |
| Open_tables                | 63    |
| Opened_files               | 209   |
| Opened_table_definitions   | 0     |
| Opened_tables              | 0     |
| Slave_open_temp_tables     | 5     |
...
+----------------------------+-------+
14 rows in set (0.00 sec)
```</p>

<p>```</p>

<h1>在master上再次创建5张临时表, 检查slave上的资源</h1>

<p>mysql-master> create temporary table test.t1 (t int);create temporary table test.t2 (t int);create temporary table test.t3 (t int);create temporary table test.t4 (t int);create temporary table test.t5 (t int);
Query OK, 0 rows affected (0.09 sec)</p>

<p>Query OK, 0 rows affected (0.00 sec)</p>

<p>Query OK, 0 rows affected (0.02 sec)</p>

<p>Query OK, 0 rows affected (0.00 sec)</p>

<p>Query OK, 0 rows affected (0.00 sec)</p>

<p>mysql-slave> show status like '%open%';
+----------------------------+-------+
| Variable_name              | Value |
+----------------------------+-------+
...
| Innodb_num_open_files      | 11    |
| Open_files                 | 22    |
| Open_streams               | 0     |
| Open_table_definitions     | 70    |
| Open_tables                | 63    |
| Opened_files               | 224   |
| Opened_table_definitions   | 0     |
| Opened_tables              | 0     |
| Slave_open_temp_tables     | 10    |
...
+----------------------------+-------+
```</p>

<p><strong>结论</strong>: 复制临时表时,slave上消耗的资源, <code>Innodb_num_open_files</code>会及时回收,也就是说实际消耗的系统资源被及时回收. 但<code>Slave_open_temp_tables</code>会虚高不下,按照Mysql Manual中"Safe slave shutdown when using temporary tables"的叙述, 用<code>Slave_open_temp_tables</code>来判断关闭server的时机时, 会出现判断失误.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[测试Mysql临时表的binlog]]></title>
    <link href="http://ikarishinjieva.github.com/blog/blog/2014/06/12/temporary-table-binlog/"/>
    <updated>2014-06-12T22:30:00+08:00</updated>
    <id>http://ikarishinjieva.github.com/blog/blog/2014/06/12/temporary-table-binlog</id>
    <content type="html"><![CDATA[<p>在Mysql 5.6.17上测试临时表生成的binlog</p>

<h3>测试用例</h3>

<p>(现在用的jekyll对table显示有点问题, 请意会...)</p>

<table>
<thead>
<tr>
<th></th>
<th>用例</th>
<th>row</th>
<th>statement</th>
<th>mixed</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td><code>create temporary table</code> 产生的binlog</td>
<td>1.1</td>
<td>1.2</td>
<td>1.3|</td>
</tr>
<tr>
<td></td>
<td><code>create temporary table</code> 产生的binlog (<code>mysqlbinlog</code>)</td>
<td>2.1</td>
<td>2.2</td>
<td>-|</td>
</tr>
<tr>
<td></td>
<td>临时表对非临时表数据产生影响时, 产生的binlog</td>
<td>3.1</td>
<td>3.2</td>
<td>-|</td>
</tr>
<tr>
<td></td>
<td>临时表对非临时表数据产生影响, 并rollback时, 产生的binlog</td>
<td>4.1</td>
<td>4.2</td>
<td>-|</td>
</tr>
<tr>
<td></td>
<td>多session同时创建临时表, 产生的binlog</td>
<td>-</td>
<td>5.1</td>
<td>-|</td>
</tr>
<tr>
<td></td>
<td>开启<code>enforce-gtid-consistency</code>时, <code>create temporary table</code></td>
<td>-</td>
<td>6.1</td>
<td>-|</td>
</tr>
</tbody>
</table>


<h3>测试结论</h3>

<h4>1. <code>create temporary table</code> 产生的binlog</h4>

<p>结论: 可以看到<code>statement</code>和<code>mixed</code>模式生成的binlog一样. 而<code>row</code>模式中, 因为临时表并没有产生实际影响, 所以没有产生额外的binlog event</p>

<h4>2. <code>create temporary table</code> 产生的binlog (<code>mysqlbinlog</code>)</h4>

<p><code>show binlog events</code> 的输出只是摘要了binlog的内容, <code>mysqlbinlog</code>的输出才能精准的显示binlog的内容</p>

<p>重做<code>row</code>模式和<code>statement</code>模式的测试, 可以看到<code>row</code>模式虽然不产生<code>create temporary table</code>, 但是会产生一个<code>drop temporary table if exists</code>; <code>statement</code>模式产生<code>create temporary table</code>, 但不产生<code>drop temporary table</code></p>

<h4>3. 临时表对非临时表数据产生影响时, 产生的binlog</h4>

<p>可以看到<code>row</code>模式会产生非临时表的行日志.<code>statement</code>模式会严格记录语句.</p>

<h4>4. 临时表对非临时表数据产生影响,并rollback时, 产生的binlog</h4>

<p>可以看到<code>row</code>模式下, rollback不会对binlog产生影响. 在<code>statement</code>模式下, 所有的语句都会如实反映在binlog里, 并进行rollback</p>

<h4>5. 多session同时创建临时表, 产生的binlog</h4>

<p>不同于典型DDL, <code>create temporary table</code>记在transaction中.</p>

<p>由session结束产生的<code>drop temporary table</code>则类似于典型的DDL.</p>

<h4>6. 开启<code>enforce-gtid-consistency</code>时, <code>create temporary table</code></h4>

<p>开启<code>enforce-gtid-consistency</code>时, 在transaction内创建临时表会得到warning:</p>

<p><code>
ERROR 1787 (HY000): When @@GLOBAL.ENFORCE_GTID_CONSISTENCY = 1, the statements CREATE TEMPORARY TABLE and DROP TEMPORARY TABLE can be executed in a non-transactional context only, and require that AUTOCOMMIT = 1.
</code></p>

<hr />

<h3>元日志</h3>

<h4>1.1</h4>

<p>```
mysql> select @@gtid_mode;
+-------------+
| @@gtid_mode |
+-------------+
| OFF         |
+-------------+
1 row in set (0.00 sec)</p>

<p>mysql> set @@session.binlog_format="row";
Query OK, 0 rows affected (0.00 sec)</p>

<p>mysql> flush logs;
Query OK, 0 rows affected (0.00 sec)</p>

<p>mysql> begin;
Query OK, 0 rows affected (0.00 sec)</p>

<p>mysql> create temporary table test.t (t int);
Query OK, 0 rows affected (0.01 sec)</p>

<p>mysql> commit;
Query OK, 0 rows affected (0.00 sec)
```</p>

<p>```
mysql> show binlog events in 'mysql-bin.000014' \G
<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><em> 1. row </em></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>
   Log_name: mysql-bin.000014</p>

<pre><code>    Pos: 4
</code></pre>

<p> Event_type: Format_desc
  Server_id: 1
End_log_pos: 120</p>

<pre><code>   Info: Server ver: 5.6.17-debug-log, Binlog ver: 4
</code></pre>

<p>```</p>

<h4>1.2</h4>

<p>```
mysql> select @@gtid_mode;</p>

<p>+-------------+
| @@gtid_mode |
+-------------+
| OFF         |
+-------------+
1 row in set (0.00 sec)</p>

<p>mysql> set @@session.binlog_format="statement";
Query OK, 0 rows affected (0.00 sec)</p>

<p>mysql> flush logs;
Query OK, 0 rows affected (0.00 sec)</p>

<p>mysql> begin;
Query OK, 0 rows affected (0.00 sec)</p>

<p>mysql> create temporary table test.t (t int);
Query OK, 0 rows affected (0.01 sec)</p>

<p>mysql> commit;
Query OK, 0 rows affected (0.00 sec)
```</p>

<p>```
mysql> show binlog events in 'mysql-bin.000015' \G
<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><em> 1. row </em></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>
   Log_name: mysql-bin.000015</p>

<pre><code>    Pos: 4
</code></pre>

<p> Event_type: Format_desc
  Server_id: 1
End_log_pos: 120</p>

<pre><code>   Info: Server ver: 5.6.17-debug-log, Binlog ver: 4
</code></pre>

<p><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><em> 2. row </em></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>
   Log_name: mysql-bin.000015</p>

<pre><code>    Pos: 120
</code></pre>

<p> Event_type: Query
  Server_id: 1
End_log_pos: 195</p>

<pre><code>   Info: BEGIN
</code></pre>

<p><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><em> 3. row </em></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>
   Log_name: mysql-bin.000015</p>

<pre><code>    Pos: 195
</code></pre>

<p> Event_type: Query
  Server_id: 1
End_log_pos: 302</p>

<pre><code>   Info: create temporary table test.t (t int)
</code></pre>

<p><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><em> 4. row </em></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>
   Log_name: mysql-bin.000015</p>

<pre><code>    Pos: 302
</code></pre>

<p> Event_type: Query
  Server_id: 1
End_log_pos: 371</p>

<pre><code>   Info: COMMIT
</code></pre>

<p>4 rows in set (0.00 sec)
```</p>

<h4>1.3</h4>

<p>```
mysql> select @@gtid_mode;
+-------------+
| @@gtid_mode |
+-------------+
| OFF         |
+-------------+
1 row in set (0.01 sec)</p>

<p>mysql> select @@binlog_format;
+-----------------+
| @@binlog_format |
+-----------------+
| MIXED           |
+-----------------+
1 row in set (0.01 sec)</p>

<p>mysql> flush logs;
Query OK, 0 rows affected (0.02 sec)</p>

<p>mysql> begin;
Query OK, 0 rows affected (0.00 sec)</p>

<p>mysql> create temporary table test.t (t int);
Query OK, 0 rows affected (0.05 sec)</p>

<p>mysql> commit;
Query OK, 0 rows affected (0.00 sec)
```</p>

<p>```
mysql> show binlog events in 'mysql-bin.000011'\G
<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><em> 1. row </em></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>
   Log_name: mysql-bin.000011</p>

<pre><code>    Pos: 4
</code></pre>

<p> Event_type: Format_desc
  Server_id: 1
End_log_pos: 120</p>

<pre><code>   Info: Server ver: 5.6.17-debug-log, Binlog ver: 4
</code></pre>

<p><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><em> 2. row </em></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>
   Log_name: mysql-bin.000011</p>

<pre><code>    Pos: 120
</code></pre>

<p> Event_type: Query
  Server_id: 1
End_log_pos: 195</p>

<pre><code>   Info: BEGIN
</code></pre>

<p><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><em> 3. row </em></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>
   Log_name: mysql-bin.000011</p>

<pre><code>    Pos: 195
</code></pre>

<p> Event_type: Query
  Server_id: 1
End_log_pos: 302</p>

<pre><code>   Info: create temporary table test.t (t int)
</code></pre>

<p><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><em> 4. row </em></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>
   Log_name: mysql-bin.000011</p>

<pre><code>    Pos: 302
</code></pre>

<p> Event_type: Query
  Server_id: 1
End_log_pos: 371</p>

<pre><code>   Info: COMMIT
</code></pre>

<p>```</p>

<h4>2.1</h4>

<p>```
[root@localhost data]# /opt/mysql/bin/mysqlbinlog --base64-output=decode-rows mysql-bin.000014
/<em>!50530 SET @@SESSION.PSEUDO_SLAVE_MODE=1</em>/;
/<em>!40019 SET @@session.max_insert_delayed_threads=0</em>/;
/<em>!50003 SET @OLD_COMPLETION_TYPE=@@COMPLETION_TYPE,COMPLETION_TYPE=0</em>/;
DELIMITER /<em>!</em>/;</p>

<h1>at 4</h1>

<h1>140612  4:38:58 server id 1  end_log_pos 120 CRC32 0xb935033a  Start: binlog v 4, server v 5.6.17-debug-log created 140612  4:38:58</h1>

<h1>at 120</h1>

<h1>140612  4:42:30 server id 1  end_log_pos 257 CRC32 0x8f9ccf27  Query   thread_id=2 exec_time=0 error_code=0</h1>

<p>SET TIMESTAMP=1402548150/<em>!</em>/;
SET @@session.pseudo_thread_id=2/<em>!</em>/;
SET @@session.foreign_key_checks=1, @@session.sql_auto_is_null=0, @@session.unique_checks=1, @@session.autocommit=1/<em>!</em>/;
SET @@session.sql_mode=1075838976/<em>!</em>/;
SET @@session.auto_increment_increment=1, @@session.auto_increment_offset=1/<em>!</em>/;
/<em>!\C utf8 </em>//<em>!</em>/;
SET @@session.character_set_client=33,@@session.collation_connection=33,@@session.collation_server=33/<em>!</em>/;
SET @@session.lc_time_names=0/<em>!</em>/;
SET @@session.collation_database=DEFAULT/<em>!</em>/;
DROP TEMPORARY TABLE IF EXISTS <code>test</code>.<code>t</code> /<em> generated by server </em>/
/<em>!</em>/;</p>

<h1>at 257</h1>

<h1>140612  4:42:51 server id 1  end_log_pos 304 CRC32 0x62766a77  Rotate to mysql-bin.000015  pos: 4</h1>

<p>DELIMITER ;</p>

<h1>End of log file</h1>

<p>ROLLBACK /<em> added by mysqlbinlog </em>/;
/<em>!50003 SET COMPLETION_TYPE=@OLD_COMPLETION_TYPE</em>/;
/<em>!50530 SET @@SESSION.PSEUDO_SLAVE_MODE=0</em>/;
```</p>

<h4>2.2</h4>

<p>```
[root@localhost data]# /opt/mysql/bin/mysqlbinlog --base64-output=decode-rows mysql-bin.000015
/<em>!50530 SET @@SESSION.PSEUDO_SLAVE_MODE=1</em>/;
/<em>!40019 SET @@session.max_insert_delayed_threads=0</em>/;
/<em>!50003 SET @OLD_COMPLETION_TYPE=@@COMPLETION_TYPE,COMPLETION_TYPE=0</em>/;
DELIMITER /<em>!</em>/;</p>

<h1>at 4</h1>

<h1>140612  4:42:51 server id 1  end_log_pos 120 CRC32 0xc3707cb7  Start: binlog v 4, server v 5.6.17-debug-log created 140612  4:42:51</h1>

<h1>Warning: this binlog is either in use or was not closed properly.</h1>

<h1>at 120</h1>

<h1>140612  4:42:58 server id 1  end_log_pos 195 CRC32 0x2fd0ed95  Query   thread_id=2 exec_time=0 error_code=0</h1>

<p>SET TIMESTAMP=1402548178/<em>!</em>/;
SET @@session.pseudo_thread_id=2/<em>!</em>/;
SET @@session.foreign_key_checks=1, @@session.sql_auto_is_null=0, @@session.unique_checks=1, @@session.autocommit=1/<em>!</em>/;
SET @@session.sql_mode=1075838976/<em>!</em>/;
SET @@session.auto_increment_increment=1, @@session.auto_increment_offset=1/<em>!</em>/;
/<em>!\C utf8 </em>//<em>!</em>/;
SET @@session.character_set_client=33,@@session.collation_connection=33,@@session.collation_server=33/<em>!</em>/;
SET @@session.lc_time_names=0/<em>!</em>/;
SET @@session.collation_database=DEFAULT/<em>!</em>/;
BEGIN
/<em>!</em>/;</p>

<h1>at 195</h1>

<h1>140612  4:42:58 server id 1  end_log_pos 302 CRC32 0xfc742b50  Query   thread_id=2 exec_time=0 error_code=0</h1>

<p>SET TIMESTAMP=1402548178/<em>!</em>/;
create temporary table test.t (t int)
/<em>!</em>/;</p>

<h1>at 302</h1>

<h1>140612  4:43:00 server id 1  end_log_pos 371 CRC32 0x25648832  Query   thread_id=2 exec_time=0 error_code=0</h1>

<p>SET TIMESTAMP=1402548180/<em>!</em>/;
COMMIT
/<em>!</em>/;
DELIMITER ;</p>

<h1>End of log file</h1>

<p>ROLLBACK /<em> added by mysqlbinlog </em>/;
/<em>!50003 SET COMPLETION_TYPE=@OLD_COMPLETION_TYPE</em>/;
/<em>!50530 SET @@SESSION.PSEUDO_SLAVE_MODE=0</em>/;
```</p>

<h4>3.1</h4>

<p>```
mysql> select @@gtid_mode;
+-------------+
| @@gtid_mode |
+-------------+
| OFF         |
+-------------+
1 row in set (0.00 sec)</p>

<p>mysql> set @@session.binlog_format="row";
Query OK, 0 rows affected (0.00 sec)</p>

<p>mysql> flush logs;
Query OK, 0 rows affected (0.01 sec)</p>

<p>mysql> begin;
Query OK, 0 rows affected (0.00 sec)</p>

<p>mysql>  create temporary table test.t (t int);
Query OK, 0 rows affected (0.01 sec)</p>

<p>mysql> insert into test.t values(2);
Query OK, 1 row affected (0.00 sec)</p>

<p>mysql> insert into test.a select t from test.t;
Query OK, 1 row affected (0.00 sec)
Records: 1  Duplicates: 0  Warnings: 0</p>

<p>mysql> commit;
Query OK, 0 rows affected (0.01 sec)
```</p>

<p>```
[root@localhost data]# /opt/mysql/bin/mysqlbinlog --base64-output=decode-rows -v mysql-bin.000020
/<em>!50530 SET @@SESSION.PSEUDO_SLAVE_MODE=1</em>/;
/<em>!40019 SET @@session.max_insert_delayed_threads=0</em>/;
/<em>!50003 SET @OLD_COMPLETION_TYPE=@@COMPLETION_TYPE,COMPLETION_TYPE=0</em>/;
DELIMITER /<em>!</em>/;</p>

<h1>at 4</h1>

<h1>140612  6:02:38 server id 1  end_log_pos 120 CRC32 0x31b6357c  Start: binlog v 4, server v 5.6.17-debug-log created 140612  6:02:38</h1>

<h1>Warning: this binlog is either in use or was not closed properly.</h1>

<h1>at 120</h1>

<h1>140612  6:02:53 server id 1  end_log_pos 188 CRC32 0x23bceabc  Query   thread_id=6 exec_time=0 error_code=0</h1>

<p>SET TIMESTAMP=1402552973/<em>!</em>/;
SET @@session.pseudo_thread_id=6/<em>!</em>/;
SET @@session.foreign_key_checks=1, @@session.sql_auto_is_null=0, @@session.unique_checks=1, @@session.autocommit=1/<em>!</em>/;
SET @@session.sql_mode=1075838976/<em>!</em>/;
SET @@session.auto_increment_increment=1, @@session.auto_increment_offset=1/<em>!</em>/;
/<em>!\C utf8 </em>//<em>!</em>/;
SET @@session.character_set_client=33,@@session.collation_connection=33,@@session.collation_server=33/<em>!</em>/;
SET @@session.lc_time_names=0/<em>!</em>/;
SET @@session.collation_database=DEFAULT/<em>!</em>/;
BEGIN
/<em>!</em>/;</p>

<h1>at 188</h1>

<h1>140612  6:02:53 server id 1  end_log_pos 232 CRC32 0x1a87cc74  Table_map: <code>test</code>.<code>a</code> mapped to number 70</h1>

<h1>at 232</h1>

<h1>140612  6:02:53 server id 1  end_log_pos 272 CRC32 0xf0c862fb  Write_rows: table id 70 flags: STMT_END_F</h1>

<h3>INSERT INTO <code>test</code>.<code>a</code></h3>

<h3>SET</h3>

<h3>@1=2</h3>

<h1>at 272</h1>

<h1>140612  6:02:55 server id 1  end_log_pos 303 CRC32 0xb2f66e82  Xid = 92</h1>

<p>COMMIT/<em>!</em>/;
DELIMITER ;</p>

<h1>End of log file</h1>

<p>ROLLBACK /<em> added by mysqlbinlog </em>/;
/<em>!50003 SET COMPLETION_TYPE=@OLD_COMPLETION_TYPE</em>/;
/<em>!50530 SET @@SESSION.PSEUDO_SLAVE_MODE=0</em>/;
```</p>

<h4>3.2</h4>

<p>```
mysql> select @@gtid_mode;
+-------------+
| @@gtid_mode |
+-------------+
| OFF         |
+-------------+
1 row in set (0.00 sec)</p>

<p>mysql> set @@session.binlog_format="statement";
Query OK, 0 rows affected (0.00 sec)</p>

<p>mysql> flush logs;
Query OK, 0 rows affected (0.00 sec)</p>

<p>mysql> begin;
Query OK, 0 rows affected (0.00 sec)</p>

<p>mysql> create temporary table test.t (t int);
Query OK, 0 rows affected (0.01 sec)</p>

<p>mysql> insert into test.t values(3);
Query OK, 1 row affected (0.00 sec)</p>

<p>mysql> insert into test.a select t from test.t;
Query OK, 1 row affected (0.00 sec)
Records: 1  Duplicates: 0  Warnings: 0</p>

<p>mysql> commit;
Query OK, 0 rows affected (0.00 sec)
```</p>

<p>```
[root@localhost data]# /opt/mysql/bin/mysqlbinlog --base64-output=decode-rows mysql-bin.000021
/<em>!50530 SET @@SESSION.PSEUDO_SLAVE_MODE=1</em>/;
/<em>!40019 SET @@session.max_insert_delayed_threads=0</em>/;
/<em>!50003 SET @OLD_COMPLETION_TYPE=@@COMPLETION_TYPE,COMPLETION_TYPE=0</em>/;
DELIMITER /<em>!</em>/;</p>

<h1>at 4</h1>

<h1>140612  6:07:43 server id 1  end_log_pos 120 CRC32 0xbcd985c3  Start: binlog v 4, server v 5.6.17-debug-log created 140612  6:07:43</h1>

<h1>Warning: this binlog is either in use or was not closed properly.</h1>

<h1>at 120</h1>

<h1>140612  6:07:50 server id 1  end_log_pos 195 CRC32 0xf5ea27f6  Query   thread_id=7 exec_time=0 error_code=0</h1>

<p>SET TIMESTAMP=1402553270/<em>!</em>/;
SET @@session.pseudo_thread_id=7/<em>!</em>/;
SET @@session.foreign_key_checks=1, @@session.sql_auto_is_null=0, @@session.unique_checks=1, @@session.autocommit=1/<em>!</em>/;
SET @@session.sql_mode=1075838976/<em>!</em>/;
SET @@session.auto_increment_increment=1, @@session.auto_increment_offset=1/<em>!</em>/;
/<em>!\C utf8 </em>//<em>!</em>/;
SET @@session.character_set_client=33,@@session.collation_connection=33,@@session.collation_server=33/<em>!</em>/;
SET @@session.lc_time_names=0/<em>!</em>/;
SET @@session.collation_database=DEFAULT/<em>!</em>/;
BEGIN
/<em>!</em>/;</p>

<h1>at 195</h1>

<h1>140612  6:07:50 server id 1  end_log_pos 302 CRC32 0xa52fbe74  Query   thread_id=7 exec_time=0 error_code=0</h1>

<p>SET TIMESTAMP=1402553270/<em>!</em>/;
create temporary table test.t (t int)
/<em>!</em>/;</p>

<h1>at 302</h1>

<h1>140612  6:07:55 server id 1  end_log_pos 400 CRC32 0x037b8754  Query   thread_id=7 exec_time=0 error_code=0</h1>

<p>SET TIMESTAMP=1402553275/<em>!</em>/;
insert into test.t values(3)
/<em>!</em>/;</p>

<h1>at 400</h1>

<h1>140612  6:07:59 server id 1  end_log_pos 509 CRC32 0xa1dc2124  Query   thread_id=7 exec_time=0 error_code=0</h1>

<p>SET TIMESTAMP=1402553279/<em>!</em>/;
insert into test.a select t from test.t
/<em>!</em>/;</p>

<h1>at 509</h1>

<h1>140612  6:08:01 server id 1  end_log_pos 540 CRC32 0xf7e3aa59  Xid = 102</h1>

<p>COMMIT/<em>!</em>/;
DELIMITER ;</p>

<h1>End of log file</h1>

<p>ROLLBACK /<em> added by mysqlbinlog </em>/;
/<em>!50003 SET COMPLETION_TYPE=@OLD_COMPLETION_TYPE</em>/;
/<em>!50530 SET @@SESSION.PSEUDO_SLAVE_MODE=0</em>/;
```</p>

<h4>4.1</h4>

<p>```
mysql> select @@gtid_mode;
+-------------+
| @@gtid_mode |
+-------------+
| OFF         |
+-------------+
1 row in set (0.00 sec)</p>

<p>mysql> set @@session.binlog_format="row";
Query OK, 0 rows affected (0.00 sec)</p>

<p>mysql> flush logs;
Query OK, 0 rows affected (0.00 sec)</p>

<p>mysql> begin;
Query OK, 0 rows affected (0.00 sec)</p>

<p>mysql> create temporary table test.t (t int);
Query OK, 0 rows affected (0.01 sec)</p>

<p>mysql> insert into test.t values(5);
Query OK, 1 row affected (0.01 sec)</p>

<p>mysql> insert into test.a select t from test.t;
Query OK, 1 row affected (0.00 sec)
Records: 1  Duplicates: 0  Warnings: 0</p>

<p>mysql> rollback;
Query OK, 0 rows affected, 1 warning (0.00 sec)</p>

<p>mysql> show warnings;
+---------+------+-----------------------------------------------------------------+
| Level   | Code | Message                                                         |
+---------+------+-----------------------------------------------------------------+
| Warning | 1751 | The creation of some temporary tables could not be rolled back. |
+---------+------+-----------------------------------------------------------------+
1 row in set (0.00 sec)
```</p>

<p>```
[root@localhost data]# /opt/mysql/bin/mysqlbinlog --base64-output=decode-rows mysql-bin.000024
/<em>!50530 SET @@SESSION.PSEUDO_SLAVE_MODE=1</em>/;
/<em>!40019 SET @@session.max_insert_delayed_threads=0</em>/;
/<em>!50003 SET @OLD_COMPLETION_TYPE=@@COMPLETION_TYPE,COMPLETION_TYPE=0</em>/;
DELIMITER /<em>!</em>/;</p>

<h1>at 4</h1>

<h1>140612  6:25:58 server id 1  end_log_pos 120 CRC32 0x8f8f4247  Start: binlog v 4, server v 5.6.17-debug-log created 140612  6:25:58</h1>

<h1>Warning: this binlog is either in use or was not closed properly.</h1>

<p>DELIMITER ;</p>

<h1>End of log file</h1>

<p>ROLLBACK /<em> added by mysqlbinlog </em>/;
/<em>!50003 SET COMPLETION_TYPE=@OLD_COMPLETION_TYPE</em>/;
/<em>!50530 SET @@SESSION.PSEUDO_SLAVE_MODE=0</em>/;
```</p>

<h4>4.2</h4>

<p>```
mysql> select @@gtid_mode;
+-------------+
| @@gtid_mode |
+-------------+
| OFF         |
+-------------+
1 row in set (0.00 sec)</p>

<p>mysql> set @@session.binlog_format="statement";
Query OK, 0 rows affected (0.00 sec)</p>

<p>mysql> flush logs;
Query OK, 0 rows affected (0.01 sec)</p>

<p>mysql> begin;
Query OK, 0 rows affected (0.00 sec)</p>

<p>mysql> create temporary table test.t (t int);
Query OK, 0 rows affected (0.01 sec)</p>

<p>mysql> insert into test.t values(4);
Query OK, 1 row affected (0.00 sec)</p>

<p>mysql> insert into test.a select t from test.t;
Query OK, 1 row affected (0.00 sec)
Records: 1  Duplicates: 0  Warnings: 0</p>

<p>mysql> rollback;
Query OK, 0 rows affected, 1 warning (0.00 sec)</p>

<p>mysql> show warnings;
+---------+------+-----------------------------------------------------------------+
| Level   | Code | Message                                                         |
+---------+------+-----------------------------------------------------------------+
| Warning | 1751 | The creation of some temporary tables could not be rolled back. |
+---------+------+-----------------------------------------------------------------+
1 row in set (0.00 sec)
```</p>

<p>```
[root@localhost data]# /opt/mysql/bin/mysqlbinlog --base64-output=decode-rows mysql-bin.000023
/<em>!50530 SET @@SESSION.PSEUDO_SLAVE_MODE=1</em>/;
/<em>!40019 SET @@session.max_insert_delayed_threads=0</em>/;
/<em>!50003 SET @OLD_COMPLETION_TYPE=@@COMPLETION_TYPE,COMPLETION_TYPE=0</em>/;
DELIMITER /<em>!</em>/;</p>

<h1>at 4</h1>

<h1>140612  6:22:03 server id 1  end_log_pos 120 CRC32 0x8ebd7db6  Start: binlog v 4, server v 5.6.17-debug-log created 140612  6:22:03</h1>

<h1>Warning: this binlog is either in use or was not closed properly.</h1>

<h1>at 120</h1>

<h1>140612  6:22:13 server id 1  end_log_pos 195 CRC32 0x2ef37ea7  Query   thread_id=9 exec_time=0 error_code=0</h1>

<p>SET TIMESTAMP=1402554133/<em>!</em>/;
SET @@session.pseudo_thread_id=9/<em>!</em>/;
SET @@session.foreign_key_checks=1, @@session.sql_auto_is_null=0, @@session.unique_checks=1, @@session.autocommit=1/<em>!</em>/;
SET @@session.sql_mode=1075838976/<em>!</em>/;
SET @@session.auto_increment_increment=1, @@session.auto_increment_offset=1/<em>!</em>/;
/<em>!\C utf8 </em>//<em>!</em>/;
SET @@session.character_set_client=33,@@session.collation_connection=33,@@session.collation_server=33/<em>!</em>/;
SET @@session.lc_time_names=0/<em>!</em>/;
SET @@session.collation_database=DEFAULT/<em>!</em>/;
BEGIN
/<em>!</em>/;</p>

<h1>at 195</h1>

<h1>140612  6:22:13 server id 1  end_log_pos 302 CRC32 0xc642d4a1  Query   thread_id=9 exec_time=0 error_code=0</h1>

<p>SET TIMESTAMP=1402554133/<em>!</em>/;
create temporary table test.t (t int)
/<em>!</em>/;</p>

<h1>at 302</h1>

<h1>140612  6:22:17 server id 1  end_log_pos 400 CRC32 0x076861c4  Query   thread_id=9 exec_time=0 error_code=0</h1>

<p>SET TIMESTAMP=1402554137/<em>!</em>/;
insert into test.t values(4)
/<em>!</em>/;</p>

<h1>at 400</h1>

<h1>140612  6:22:21 server id 1  end_log_pos 509 CRC32 0x2e43db50  Query   thread_id=9 exec_time=0 error_code=0</h1>

<p>SET TIMESTAMP=1402554141/<em>!</em>/;
insert into test.a select t from test.t
/<em>!</em>/;</p>

<h1>at 509</h1>

<h1>140612  6:22:24 server id 1  end_log_pos 580 CRC32 0xdefa8f3d  Query   thread_id=9 exec_time=0 error_code=0</h1>

<p>SET TIMESTAMP=1402554144/<em>!</em>/;
ROLLBACK
/<em>!</em>/;
DELIMITER ;</p>

<h1>End of log file</h1>

<p>ROLLBACK /<em> added by mysqlbinlog </em>/;
/<em>!50003 SET COMPLETION_TYPE=@OLD_COMPLETION_TYPE</em>/;
/<em>!50530 SET @@SESSION.PSEUDO_SLAVE_MODE=0</em>/;
```</p>

<h4>5.1</h4>

<p>```
mysql-session1> set @@session.binlog_format="statement";
Query OK, 0 rows affected (0.00 sec)</p>

<p>mysql-session2> set @@session.binlog_format="statement";
Query OK, 0 rows affected (0.00 sec)</p>

<p>mysql-session1> flush logs;
Query OK, 0 rows affected (0.00 sec)</p>

<p>mysql-session1> begin;
Query OK, 0 rows affected (0.00 sec)</p>

<p>mysql-session1> create temporary table test.t(t int);
Query OK, 0 rows affected (0.01 sec)</p>

<p>mysql-session2> begin;
Query OK, 0 rows affected (0.00 sec)</p>

<p>mysql-session2> create temporary table test.t(t int);
Query OK, 0 rows affected (0.02 sec)</p>

<p>mysql-session1> commit;
Query OK, 0 rows affected (0.00 sec)</p>

<p>mysql-session2> commit;
Query OK, 0 rows affected (0.00 sec)</p>

<p>mysql-session1> exit;
Bye</p>

<p>mysql-session2> exit;
Bye
```</p>

<p>```</p>

<p>[root@localhost data]# /opt/mysql/bin/mysqlbinlog --base64-output=decode-rows mysql-bin.000028
/<em>!50530 SET @@SESSION.PSEUDO_SLAVE_MODE=1</em>/;
/<em>!40019 SET @@session.max_insert_delayed_threads=0</em>/;
/<em>!50003 SET @OLD_COMPLETION_TYPE=@@COMPLETION_TYPE,COMPLETION_TYPE=0</em>/;
DELIMITER /<em>!</em>/;</p>

<h1>at 4</h1>

<h1>140612  6:45:24 server id 1  end_log_pos 120 CRC32 0x0ad8e5a0  Start: binlog v 4, server v 5.6.17-debug-log created 140612  6:45:24</h1>

<h1>Warning: this binlog is either in use or was not closed properly.</h1>

<h1>at 120</h1>

<h1>140612  6:45:58 server id 1  end_log_pos 195 CRC32 0x59b581d0  Query   thread_id=14    exec_time=0 error_code=0</h1>

<p>SET TIMESTAMP=1402555558/<em>!</em>/;
SET @@session.pseudo_thread_id=14/<em>!</em>/;
SET @@session.foreign_key_checks=1, @@session.sql_auto_is_null=0, @@session.unique_checks=1, @@session.autocommit=1/<em>!</em>/;
SET @@session.sql_mode=1075838976/<em>!</em>/;
SET @@session.auto_increment_increment=1, @@session.auto_increment_offset=1/<em>!</em>/;
/<em>!\C utf8 </em>//<em>!</em>/;
SET @@session.character_set_client=33,@@session.collation_connection=33,@@session.collation_server=33/<em>!</em>/;
SET @@session.lc_time_names=0/<em>!</em>/;
SET @@session.collation_database=DEFAULT/<em>!</em>/;
BEGIN
/<em>!</em>/;</p>

<h1>at 195</h1>

<h1>140612  6:45:58 server id 1  end_log_pos 301 CRC32 0x274004b9  Query   thread_id=14    exec_time=0 error_code=0</h1>

<p>SET TIMESTAMP=1402555558/<em>!</em>/;
create temporary table test.t(t int)
/<em>!</em>/;</p>

<h1>at 301</h1>

<h1>140612  6:46:54 server id 1  end_log_pos 370 CRC32 0x9f2ca921  Query   thread_id=14    exec_time=0 error_code=0</h1>

<p>SET TIMESTAMP=1402555614/<em>!</em>/;
COMMIT
/<em>!</em>/;</p>

<h1>at 370</h1>

<h1>140612  6:46:17 server id 1  end_log_pos 445 CRC32 0x3f1094c3  Query   thread_id=16    exec_time=0 error_code=0</h1>

<p>SET TIMESTAMP=1402555577/<em>!</em>/;
SET @@session.pseudo_thread_id=16/<em>!</em>/;
BEGIN
/<em>!</em>/;</p>

<h1>at 445</h1>

<h1>140612  6:46:17 server id 1  end_log_pos 551 CRC32 0x754cae85  Query   thread_id=16    exec_time=0 error_code=0</h1>

<p>SET TIMESTAMP=1402555577/<em>!</em>/;
create temporary table test.t(t int)
/<em>!</em>/;</p>

<h1>at 551</h1>

<h1>140612  6:46:58 server id 1  end_log_pos 620 CRC32 0x73eb6f5a  Query   thread_id=16    exec_time=0 error_code=0</h1>

<p>SET TIMESTAMP=1402555618/<em>!</em>/;
COMMIT
/<em>!</em>/;</p>

<h1>at 620</h1>

<h1>140612  6:47:22 server id 1  end_log_pos 733 CRC32 0xb4c3b1c0  Query   thread_id=14    exec_time=0 error_code=0</h1>

<p>use <code>test</code>/<em>!</em>/;
SET TIMESTAMP=1402555642/<em>!</em>/;
SET @@session.pseudo_thread_id=14/<em>!</em>/;
DROP /<em>!40005 TEMPORARY </em>/ TABLE IF EXISTS <code>t</code>
/<em>!</em>/;</p>

<h1>at 733</h1>

<h1>140612  6:47:38 server id 1  end_log_pos 846 CRC32 0x1287fb24  Query   thread_id=16    exec_time=0 error_code=0</h1>

<p>SET TIMESTAMP=1402555658/<em>!</em>/;
SET @@session.pseudo_thread_id=16/<em>!</em>/;
DROP /<em>!40005 TEMPORARY </em>/ TABLE IF EXISTS <code>t</code>
/<em>!</em>/;
DELIMITER ;</p>

<h1>End of log file</h1>

<p>ROLLBACK /<em> added by mysqlbinlog </em>/;
/<em>!50003 SET COMPLETION_TYPE=@OLD_COMPLETION_TYPE</em>/;
/<em>!50530 SET @@SESSION.PSEUDO_SLAVE_MODE=0</em>/;
```</p>

<h4>6.1</h4>

<p>```
mysql> select @@GTID_MODE;
+-------------+
| @@GTID_MODE |
+-------------+
| ON          |
+-------------+
1 row in set (0.00 sec)</p>

<p>mysql> select @@enforce_gtid_consistency;
+----------------------------+
| @@enforce_gtid_consistency |
+----------------------------+
|                          1 |
+----------------------------+
1 row in set (0.00 sec)</p>

<p>mysql> begin;
Query OK, 0 rows affected (0.00 sec)</p>

<p>mysql> create temporary table test.t(t int);
ERROR 1787 (HY000): When @@GLOBAL.ENFORCE_GTID_CONSISTENCY = 1, the statements CREATE TEMPORARY TABLE and DROP TEMPORARY TABLE can be executed in a non-transactional context only, and require that AUTOCOMMIT = 1.
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[对mysql table_cache的理解]]></title>
    <link href="http://ikarishinjieva.github.com/blog/blog/2014/05/15/mysql-table-cache/"/>
    <updated>2014-05-15T20:59:00+08:00</updated>
    <id>http://ikarishinjieva.github.com/blog/blog/2014/05/15/mysql-table-cache</id>
    <content type="html"><![CDATA[<p>最近读了mysql table_cache部分的一些代码.</p>

<p>首先推荐这篇<a href="http://blog.sina.com.cn/s/blog_4673e60301010r5u.html">导读</a>, 写的比较详尽. 不对其中已有的部分进行重复, 仅记录自己的一些理解.</p>

<h4>最简单的功能</h4>

<p>叫做table_cache, 就是对<code>table</code>做擦车(cache).</p>

<p>其中<code>table</code>是指的mysql打开的表的描述结构(descriptor)(<a href="http://osxr.org/mysql/source/sql/table.h#0974"><code>TABLE</code></a>),  简单理解就是mysql要操作一张表时, 就会先打开其descriptor, 打开后读取其中信息, 然后进行操作.</p>

<p>为了快速访问, cache 往往类似于 Hash. table_cache 的 key 是</p>

<pre><code>db_name + table_name
</code></pre>

<p>table_cache 的 value 是 descriptor 的集合, 即 <a href="http://osxr.org/mysql/source/sql/table_cache.h#0208"><code>Table_cache_element</code></a>.</p>

<p>value 是 descriptor 的集合而不是 descriptor, 是因为对于同一张表, 在cache中同时会打开多个 descriptor</p>

<p>额外一提, table_cache是按线程号分桶的, 参看<code>Table_cache_manager</code></p>

<h4>进一步, 留下被回收的元素</h4>

<p>传统擦车, 不用的元素就直接回收了. table_cache暂存了不用的元素, 提高命中率.</p>

<p>可以看到<code>Table_cache_element</code>一共两个列表:</p>

<ul>
<li>used_tables</li>
<li>free_tables</li>
</ul>


<h4>进一步, 抽出共同的部分</h4>

<p>同一张表的多个 descriptor, 会有公共部分, 抽出这些公共部分, 能有效节省资源.</p>

<p>比如<code>mem_root</code> (个人称之为受管内存区), 此内存区管理着跟某表相关的一些数据结构, 且受mysqld的管制. 如果同一张表的每个 descriptor 都独立管理一篇内存, 会引起不必要的浪费.</p>

<p>抽出的公共部分称为<a href="http://osxr.org/mysql/source/sql/table.h#0584"><code>TABLE_SHARE</code></a></p>

<h4>进一步, 公共部分也得擦车</h4>

<p><code>TABLE_SHARE</code> 也被擦车了, 其被回收的元素跟<code>TABLE</code>一样也被擦车了.</p>

<h4>擦车的步骤</h4>

<p>简述擦车的步骤</p>

<ol>
<li>在cache中查找<code>TABLE</code></li>
<li>如果找到<code>TABLE</code>, 则成功</li>
<li>在cache中查找<code>TABLE_SHARE</code></li>
<li>如果找不到<code>TABLE_SHARE</code>, 则生成一个</li>
<li>根据<code>TABLE_SHARE</code>, 生成一个<code>TABLE</code></li>
<li>维护好cache</li>
</ol>


<h4>如果找不到<code>TABLE_SHARE</code></h4>

<p>参看<a href="http://osxr.org/mysql/ident?_i=get_table_share_with_discover"><code>get_table_share_with_discover</code></a></p>

<p>如果内存中找不到<code>TABLE_SHARE</code>, 则向存储引擎查询, 如果存储引擎可以提供, 则进行<a href="http://osxr.org/mysql/ident?_i=recover_from_failed_open">discover</a></p>

<h4>关于死锁</h4>

<p>table_cache 里有很多代码是关于死锁的处理, 其一个主要原因是因为 mysql 分为了sql层和存储引擎层, MDL的死锁检测限于sql层, 存储引擎层自带死锁检测, 但一个死锁如果跨过两层, 则需要特殊处理</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PREVIOUS_GTIDS_LOG_EVENT的格式]]></title>
    <link href="http://ikarishinjieva.github.com/blog/blog/2014/04/17/PREVIOUS_GTIDS_LOG_EVENT/"/>
    <updated>2014-04-17T22:08:00+08:00</updated>
    <id>http://ikarishinjieva.github.com/blog/blog/2014/04/17/PREVIOUS_GTIDS_LOG_EVENT</id>
    <content type="html"><![CDATA[<p>并没找到特别好的对<code>PREVIOUS_GTIDS_LOG_EVENT</code>格式的描述, 自己写一个</p>

<p>据下面这个例子, 是<code>mysqlbinlog</code>的分析结果</p>

<pre><code># at 120
#140417 15:50:36 server id 904898000  end_log_pos 311 CRC32 0x311ec069
# Position  Timestamp   Type   Master ID        Size      Master Pos    Flags
#       78 cc 87 4f 53   23   d0 a5 ef 35   bf 00 00 00   37 01 00 00   00 00
#       8b 04 00 00 00 00 00 00 00  7e 23 40 1a c6 03 11 e3 |................|
#       9b 8e 13 5e 10 e6 a0 5c fb  01 00 00 00 00 00 00 00 |................|
#       ab 01 00 00 00 00 00 00 00  06 00 00 00 00 00 00 00 |................|
#       bb 81 86 fc 1e c5 ff 11 e3  8d f9 e6 6c cf 50 db 66 |...........l.P.f|
#       cb 01 00 00 00 00 00 00 00  01 00 00 00 00 00 00 00 |................|
#       db 0c 00 00 00 00 00 00 00  a6 ce 32 8c c6 02 11 e3 |..........2.....|
#       eb 8e 0d e6 6c cf 50 db 66  01 00 00 00 00 00 00 00 |...l.P.f........|
#       fb 01 00 00 00 00 00 00 00  07 00 00 00 00 00 00 00 |................|
#      10b b7 00 99 20 c6 01 11 e3  8e 07 5e 10 e6 a0 5c fb |................|
#      11b 01 00 00 00 00 00 00 00  01 00 00 00 00 00 00 00 |................|
#      12b 07 00 00 00 00 00 00 00  69 c0 1e 31             |........i..1|
#      Previous-GTIDs
# 7e23401a-c603-11e3-8e13-5e10e6a05cfb:1-5,
# 8186fc1e-c5ff-11e3-8df9-e66ccf50db66:1-11,
# a6ce328c-c602-11e3-8e0d-e66ccf50db66:1-6,
# b7009920-c601-11e3-8e07-5e10e6a05cfb:1-6
</code></pre>

<p>从78-8a的位置, 是Binlog Event header, 参看<a href="http://dev.mysql.com/doc/internals/en/binlog-event-header.html">这里</a></p>

<p>最后四个字节, (69 c0 1e 31) 是checksum, 与参数 <a href="http://dev.mysql.com/doc/refman/5.6/en/replication-options-binary-log.html#option_mysqld_binlog-checksum">binlog-checksum</a> 有关</p>

<p>中间的部分, 是gtid的数据区, 格式如下:</p>

<table>
<thead>
<tr>
<th>层次 </th>
<th> 字节数 </th>
<th> 含义 </th>
<th> 例子中的数值</th>
</tr>
</thead>
<tbody>
<tr>
<td>0 </td>
<td> 8 </td>
<td> GTID中sid-number的组数 </td>
<td> 例子中为四组</td>
</tr>
<tr>
<td>1 </td>
<td> 16 </td>
<td> 第一组sid-number的sid部分 </td>
<td> 例子中为(7e 23 40 1a c6 03 11 e3 9b 8e 13 5e 10 e6 a0 5c fb)</td>
</tr>
<tr>
<td>1 </td>
<td> 8 </td>
<td> 第一组sid-number中, internal numbers的个数 </td>
<td> 例子中为1个internal number (<code>1-5</code>)</td>
</tr>
<tr>
<td>2 </td>
<td> 8 </td>
<td> 第一组sid-number中, 第一个internal number的起始number </td>
<td> 例子中为<code>1</code></td>
</tr>
<tr>
<td>2 </td>
<td> 8 </td>
<td> 第一组sid-number中, 第一个internal number的结束number+1 </td>
<td> 例子中为<code>5+1=6</code></td>
</tr>
<tr>
<td>2 </td>
<td> 8 </td>
<td> 第一组sid-number中, 第二个internal number的起始number </td>
<td> ... (例子中没有第二个internal number)</td>
</tr>
<tr>
<td>2 </td>
<td> 8 </td>
<td> 第一组sid-number中, 第二个internal number的结束number+1 </td>
<td> ... (例子中没有第二个internal number)</td>
</tr>
<tr>
<td>... </td>
<td> ... </td>
<td> ... </td>
<td> ...</td>
</tr>
<tr>
<td>1 </td>
<td> 16 </td>
<td> 第二组sid-number的sid部分 </td>
<td> ...</td>
</tr>
<tr>
<td>... </td>
<td> ... </td>
<td> ... </td>
<td> ...</td>
</tr>
</tbody>
</table>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MDL_map_partition中对锁的过渡]]></title>
    <link href="http://ikarishinjieva.github.com/blog/blog/2014/04/05/MDL_map_partition-lock-split/"/>
    <updated>2014-04-05T11:43:00+08:00</updated>
    <id>http://ikarishinjieva.github.com/blog/blog/2014/04/05/MDL_map_partition-lock-split</id>
    <content type="html"><![CDATA[<p>在<code>MDL</code>源码中有一段<code>MDL_map_partition</code>中对锁的过渡有点意思, 拿出来分析一下</p>

<h4>场景</h4>

<p><code>MDL_map_partition</code>是容纳<code>MDL_lock</code>的一个容器, <code>MDL_lock</code>可以简单的理解为一种锁.</p>

<p>那么场景问题是现在我要从锁容器<code>C</code>中查找一个锁<code>L</code>并加锁<code>L</code>, 怎样做到多线程安全</p>

<p>场景中<code>C</code>上有保护<code>C</code>的锁<code>A</code> (容器锁), <code>L</code>上的锁为<code>B</code> (成员锁) (此处做了简化, 实际上<code>MDL_lock</code>并不是一个锁, 而是类似于条件变量, 而锁<code>B</code>是保护<code>L</code>的锁. 此处将<code>L</code>简化为一把锁)</p>

<h4>分析1</h4>

<p>最简单的方法, 就是<code>A</code>加锁, <code>B</code>加锁, <code>A</code>解锁. 这种方法肯定不会有错, 但是并发性上会出现问题. 比如以下场景</p>

<ol>
<li>线程T1持有<code>B</code></li>
<li>线程T2正在容器中查找<code>B</code>.</li>
<li>线程T3在同一个容器中查找另外一个<code>MDL_lock</code></li>
</ol>


<p>T2先将<code>A</code>加锁, 加锁<code>B</code>时, 由于T1持有<code>B</code>, T2被阻塞; T3在同一个容器中查找另一个不相关的成员, 先要加锁<code>A</code>, <code>A</code>被T2持有, T3被阻塞</p>

<p>因此, 这种做法的并发性很差</p>

<h4>分析2</h4>

<p>提高并发性的关键是将<code>A</code>锁过渡到<code>B</code>锁, 比如这样: <code>A</code>加锁, 查找<code>B</code>, <code>A</code>解锁, <code>B</code>加锁.</p>

<p>这种方法解决了并发性, 但显而易见形成了一个无锁区 (从<code>A</code>解锁到<code>B</code>加锁这个区域). 如果在无锁区另一个线程将<code>B</code>销毁或移出容器, 那么后面的<code>B</code>加锁操作就会悲剧</p>

<h4>分析3</h4>

<p>面对无锁区的问题, 可以试着加<code>version</code>(版本变量)来解决, 规则如下:</p>

<ul>
<li>任何将成员移入/移出容器的情况, 都需要获得容器锁<code>A</code>和成员锁<code>B</code>, 并在元素<code>version</code>上加1</li>
<li>对成员的销毁, 需要先将成员移出容器</li>
</ul>


<p>这样, 查找成员的流程变为:</p>

<ol>
<li>线程T1, 对<code>A</code>加锁, 找到<code>B</code>, 记录<code>B</code>的<code>version</code>, 记为v1. 对<code>A</code>解锁</li>
<li>线程T2, <code>B</code>销毁或移出容器, 需要获得<code>A</code>和<code>B</code>锁, 对<code>version</code>加1, 记为v2</li>
<li>线程T1, 等到T2释放<code>B</code>锁后, 可获得<code>B</code>锁, 发现<code>v1 != v2</code>, 意味着成员可能在容器中已经被移出或销毁, 则需要重试整个过程</li>
</ol>


<p>加入<code>version</code>后, 对于销毁成员的场景, 并发性并没有改变 (因为仍然需要同时获得两把锁), 但对于查找成员的场景, 并发性和分析2一样</p>

<p>不幸的是, 这个场景仍然存在问题, 很容易看到其中一个逻辑问题, T1在T2销毁<code>B</code>锁后, 还获得了<code>B</code>锁. 也就是T2不能即刻销毁<code>B</code>锁, 否则所有等待<code>B</code>锁的线程都会悲剧. 那<code>B</code>锁何时能被安全销毁</p>

<h4>分析4</h4>

<p>要解决分析3的问题, 可以在<code>B</code>上添加引用计数, 细节如下:</p>

<ul>
<li>在成员未被移出容器时, 持有<code>A</code>锁可以对成员引用计数<code>usage_count</code>进行加1, 即在容器中查找成员时, 容器负责对成员的<code>usage_count</code>加1</li>
<li>持有<code>B</code>锁可以对自己的解引用计数<code>release_count</code>进行加1, 即使用者在使用完<code>B</code>后, 对<code>B</code>进行解引用</li>
<li>如果<code>usage_count</code> == <code>release_count</code>, 则<code>B</code>可以被安全销毁</li>
</ul>


<p>可以看到<code>usage_count</code>和<code>release_count</code>在分别在不同锁的保护下, 代入分析3的场景, 发现可以解决分析3的问题</p>

<p>还有一些需要说明的边界情况</p>

<ul>
<li>在成员已经被移出容器后, 成员引用计数<code>usage_count</code>不再受<code>A</code>锁保护, 而是受<code>B</code>锁保护. 相当于容器已经不再管理成员的引用计数</li>
<li>如何判断"成员已经被移出容器", 可以在成员上添加状态量<code>is_removed_from_container</code>, 读取此状态需要<code>A</code>锁或<code>B</code>锁, 修改此状态需要<code>A</code>锁和<code>B</code>锁.</li>
</ul>


<h4>Mysql的实现</h4>

<p>Mysql的实现和之前的分析大致相同, 给出映射表</p>

<table>
<thead>
<tr>
<th>分析里的概念 </th>
<th> Mysql的变量</th>
</tr>
</thead>
<tbody>
<tr>
<td>版本变量<code>version</code> </td>
<td> <code>MDL_lock.m_version</code></td>
</tr>
<tr>
<td>成员引用计数<code>usage_count</code> </td>
<td> <code>MDL_lock.m_ref_usage</code></td>
</tr>
<tr>
<td>成员解引用计数<code>release_count</code> </td>
<td> <code>MDL_lock.m_ref_release</code></td>
</tr>
<tr>
<td>状态量<code>is_removed_from_container</code> </td>
<td> <code>MDL_lock.m_is_destroyed</code></td>
</tr>
</tbody>
</table>


<p>实现锁拆分的函数为<code>MDL_map_partition::move_from_hash_to_lock_mutex</code>, 一看就懂</p>
]]></content>
  </entry>
  
</feed>
