<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: go | Tac say]]></title>
  <link href="http://ikarishinjieva.github.com/blog/blog/categories/go/atom.xml" rel="self"/>
  <link href="http://ikarishinjieva.github.com/blog/"/>
  <updated>2014-02-22T11:00:56+08:00</updated>
  <id>http://ikarishinjieva.github.com/blog/</id>
  <author>
    <name><![CDATA[Tac Huang (ikari_shinji@github)]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[GO exec.command.Wait 执行后台程序,在重定向输出时卡住]]></title>
    <link href="http://ikarishinjieva.github.com/blog/blog/2014/02/22/go-exec-command-block-when-redirect-stdout/"/>
    <updated>2014-02-22T10:30:00+08:00</updated>
    <id>http://ikarishinjieva.github.com/blog/blog/2014/02/22/go-exec-command-block-when-redirect-stdout</id>
    <content type="html"><![CDATA[<p>在GO上发现以下现象</p>

<pre><code>c := exec.Command("sh", "-c", "sleep 100 &amp;")
var b bytes.Buffer
c.Stdout = &amp;b

if e := c.Start(); nil != e {
    fmt.Printf("ERROR: %v\n", e)
}
if e := c.Wait(); nil != e {
    fmt.Printf("ERROR: %v\n", e)
}
</code></pre>

<p>这个代码会一直等到<code>sleep 100</code>完成后才退出, 与常识不符.</p>

<p>但去掉Stdout重定向后, 代码就不会等待卡住</p>

<pre><code>c := exec.Command("sh", "-c", "sleep 100 &amp;")
if e := c.Start(); nil != e {
    fmt.Printf("ERROR: %v\n", e)
}
if e := c.Wait(); nil != e {
    fmt.Printf("ERROR: %v\n", e)
}
</code></pre>

<p>在运行时打出stacktrace, 再翻翻GO的源代码, 发现GO卡在以下代码</p>

<pre><code>func (c *Cmd) Wait() error {
    ...
    state, err := c.Process.Wait()
    ...
    var copyError error
    for _ = range c.goroutine {
        if err := &lt;-c.errch; err != nil &amp;&amp; copyError == nil {
            copyError = err
        }
    }
    ...
}
</code></pre>

<p>可以看到<code>Wait()</code>在等待Process结束后, 还等待了所有<code>c.goroutine</code>的<code>c.errch</code>信号. 参看以下代码:</p>

<pre><code>func (c *Cmd) stdout() (f *os.File, err error) {
    return c.writerDescriptor(c.Stdout)
}

func (c *Cmd) writerDescriptor(w io.Writer) (f *os.File, err error) {
    ...
    c.goroutine = append(c.goroutine, func() error {
        _, err := io.Copy(w, pr)
        return err
    })
    ...
}
</code></pre>

<p>重定向<code>stdout</code>时, 会添加一个监听任务到<code>goroutine</code> (<code>stderr</code>也是同理)</p>

<p>结论是由于将<code>sleep 100</code>放到后台执行, 其进程<code>stdout</code>并没有关闭, <code>io.Copy()</code>不会返回, 所以会卡住</p>

<p>临时的解决方法就是将后台进程的<code>stdout</code>和<code>stderr</code>重定向出去, 以下代码不会卡住:</p>

<pre><code>c := exec.Command("sh", "-c", "sleep 100 &gt;/dev/null 2&gt;/dev/null &amp;")
var b bytes.Buffer
c.Stdout = &amp;b

if e := c.Start(); nil != e {
    fmt.Printf("ERROR: %v\n", e)
}
if e := c.Wait(); nil != e {
    fmt.Printf("ERROR: %v\n", e)
}
</code></pre>

<p>已经报了<a href="https://code.google.com/p/go/issues/detail?id=7378&amp;thanks=7378&amp;ts=1392967848">bug</a></p>

<p>但想不出好的GO代码的修改方案</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[栽在Go中for的变量]]></title>
    <link href="http://ikarishinjieva.github.com/blog/blog/2013/12/26/go-iterate-variable/"/>
    <updated>2013-12-26T22:13:00+08:00</updated>
    <id>http://ikarishinjieva.github.com/blog/blog/2013/12/26/go-iterate-variable</id>
    <content type="html"><![CDATA[<p>我是万没料到自己栽在了go的for上，说多了都是眼泪</p>

<p>``` go
type testStruct struct {</p>

<pre><code> no int
</code></pre>

<p>}</p>

<p>func main() {</p>

<pre><code> a := []testStruct{testStruct{1}, testStruct{2}, testStruct{3}}
 var p *testStruct
 for _, i := range a {
      if i.no == 2 {
           // o := i
           // p = &amp;o
           p = &amp;i
      }
 }
 fmt.Println(p.no)
</code></pre>

<p>}
```</p>

<p>猜猜看输出是多少？<a href="http://play.golang.org/p/OzkxuYIboc">试试看吧</a></p>

<p>理解起来很容易，<code>p</code>取得是<code>i</code>的地址，而<strong>range循环变量<code>i</code>在每个循环之间都是复用同一个地址</strong></p>

<p>证明一下，<a href="http://play.golang.org/p/b3QFcoh35Q">试试看？</a></p>

<p>```go
a := []int{1, 2, 3, 4, 5}
for _, item := range a {</p>

<pre><code> fmt.Printf("%p\n", &amp;item)
</code></pre>

<p>}
```</p>

<p>虽然很容易理解，也很容易掉坑，尤其for上用<code>:=</code>，那感觉就像js里连续用<code>var</code>，除了第一下剩下的都不好使...</p>
]]></content>
  </entry>
  
</feed>
