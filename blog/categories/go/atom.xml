<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: go | Tac say]]></title>
  <link href="http://ikarishinjieva.github.com/blog/blog/categories/go/atom.xml" rel="self"/>
  <link href="http://ikarishinjieva.github.com/blog/"/>
  <updated>2014-03-26T21:17:39+08:00</updated>
  <id>http://ikarishinjieva.github.com/blog/</id>
  <author>
    <name><![CDATA[Tac Huang (ikari_shinji@github)]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[golang, cmd会泄露文件句柄]]></title>
    <link href="http://ikarishinjieva.github.com/blog/blog/2014/03/25/go-leak-fd/"/>
    <updated>2014-03-25T22:34:00+08:00</updated>
    <id>http://ikarishinjieva.github.com/blog/blog/2014/03/25/go-leak-fd</id>
    <content type="html"><![CDATA[<p>在go中用<code>cmd</code>生成新的process时, 在某些os中(包括linux的某些版本), 父进程的文件句柄会泄露到子进程中, 参看代码</p>

<pre><code>package main

import (
    "fmt"
    "os"
    "os/exec"
)

func main() {
    a, _ := os.OpenFile("1", os.O_CREATE|os.O_RDWR, 0755)
    defer a.Close()
    cmd := exec.Command("sh", "-c", "lsof +D .; sleep 3")
    output, _ := cmd.CombinedOutput()
    fmt.Printf("%v\n", string(output))
}
</code></pre>

<p>得到输出</p>

<pre><code>[root@GroupH-HA-1 tmp]# uname -a
Linux GroupH-HA-1 2.6.18-194.el5xen #1 SMP Tue Mar 16 22:01:26 EDT 2010 x86_64 x86_64 x86_64 GNU/Linux
[root@GroupH-HA-1 tmp]# ./main
COMMAND  PID USER   FD   TYPE DEVICE    SIZE    NODE NAME
bash    4693 root  cwd    DIR  253,0   32768 3506177 .
main    6184 root  cwd    DIR  253,0   32768 3506177 .
main    6184 root  txt    REG  253,0 2250464 3506237 ./main
main    6184 root    3u   REG  253,0       0 3506238 ./1
sh      6189 root  cwd    DIR  253,0   32768 3506177 .
sh      6189 root    3u   REG  253,0       0 3506238 ./1
lsof    6190 root  cwd    DIR  253,0   32768 3506177 .
lsof    6191 root  cwd    DIR  253,0   32768 3506177 .
</code></pre>

<p>可以看到<code>./1</code>的文件句柄泄漏到了<code>sh -c</code>中, 目前为止没有特别好的解决方案</p>

<p>参看<a href="https://code.google.com/p/go/issues/detail?id=2603">此处bug描述</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[golang, windows和linux上的文件锁]]></title>
    <link href="http://ikarishinjieva.github.com/blog/blog/2014/03/20/go-file-lock/"/>
    <updated>2014-03-20T22:43:00+08:00</updated>
    <id>http://ikarishinjieva.github.com/blog/blog/2014/03/20/go-file-lock</id>
    <content type="html"><![CDATA[<p>直接上代码, <code>LockFile</code>可以获得一个文件的独占权, 或阻塞等待</p>

<h4>linux</h4>

<pre><code>func LockFile(file *os.File) error {
    return syscall.Flock(int(file.Fd()), syscall.LOCK_EX)
}
</code></pre>

<h4>windows</h4>

<pre><code>func LockFile(file *os.File) error {
    h, err := syscall.LoadLibrary("kernel32.dll")
    if err != nil {
        return err
    }
    defer syscall.FreeLibrary(h)

    addr, err := syscall.GetProcAddress(h, "LockFile")
    if err != nil {
        return err
    }
    for {
        r0, _, _ := syscall.Syscall6(addr, 5, file.Fd(), 0, 0, 0, 1, 0)
        if 0 != int(r0) {
            break
        }
        time.Sleep(100 * time.Millisecond)
    }
    return nil
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[推荐下我修改的gen]]></title>
    <link href="http://ikarishinjieva.github.com/blog/blog/2014/03/02/gen/"/>
    <updated>2014-03-02T21:29:00+08:00</updated>
    <id>http://ikarishinjieva.github.com/blog/blog/2014/03/02/gen</id>
    <content type="html"><![CDATA[<p><a href="http://clipperhouse.github.io/gen/"><code>gen</code></a>是go的代码生成器, 提供类似于<code>underscore</code>的函数集.</p>

<p>尝试将<code>gen</code>用在项目上,发现不太方便,对源码做了如下两个修改, 修改后的代码在<a href="https://github.com/ikarishinjieva/gen">这里</a>:</p>

<h4>1. 支持条件编译</h4>

<p>go提供了条件编译,根据<code>GOOS</code>和<code>GOARCH</code>进行交叉编译,也可以利用<a href="http://golang.org/cmd/go"><code>build tags</code></a>自定义条件编译</p>

<p>修改前可能碰到的问题是存在<code>a_linux.go</code>和<code>a_windows.go</code>, 分别定义一个函数<code>A</code>的两个版本. 调用<code>gen</code>时会报错:<code>A</code>不可以重复定义</p>

<p>这个修改已经被merge回原分支</p>

<h4>2. 对于import的其它包, 支持分析其源码</h4>

<p>设想一个场景, 存在<code>root/A</code>和<code>root/B</code>两个包, <code>root/B</code> import <code>root/A</code></p>

<p>在<code>root/B</code>上调用<code>gen</code>, <code>gen</code>会分析import关系, 找到并分析<code>root/A</code></p>

<p>在修改之前, 由于<code>gen</code>只使用了<code>types.Check</code>, 默认只会使用<code>gcimport</code>,只分析<code>root/A</code>编译好的pkg(<code>.a</code>文件), 而不包括<code>root/A</code>的源码.</p>

<p>也就是说对于所有依赖, 必须都保证其跑过<code>go install</code>, 才能在下游模块使用<code>gen</code>. 这个并不方便</p>

<p>做的修改是使用<code>go.tools/importer</code>代替<code>gcimporter</code>, 既可以分析编译好的pkg, 又可以分析源码</p>

<p>不过这个修改的代价是分析的时间会比较长</p>

<p>这个修改尚未被原分支接受</p>

<h4>3. <code>types</code>源码分析的一个问题</h4>

<p>以下代码在分析源码时报错, 但编译时是通过的</p>

<pre><code>c := make(chan os.Signal, 1)
signal.Notify(c, syscall.SIGTTIN)
</code></pre>

<p>分析时报的错是</p>

<pre><code>cannot pass argument c (variable of type chan os.Signal) to parameter of type chan&lt;- os.Signal
</code></pre>

<p>目前无解, 但结论是用<code>types</code>包进行的源码分析结果和编译时的略有差异</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[GO exec.command.Wait 执行后台程序,在重定向输出时卡住]]></title>
    <link href="http://ikarishinjieva.github.com/blog/blog/2014/02/22/go-exec-command-block-when-redirect-stdout/"/>
    <updated>2014-02-22T10:30:00+08:00</updated>
    <id>http://ikarishinjieva.github.com/blog/blog/2014/02/22/go-exec-command-block-when-redirect-stdout</id>
    <content type="html"><![CDATA[<p>在GO上发现以下现象</p>

<pre><code>c := exec.Command("sh", "-c", "sleep 100 &amp;")
var b bytes.Buffer
c.Stdout = &amp;b

if e := c.Start(); nil != e {
    fmt.Printf("ERROR: %v\n", e)
}
if e := c.Wait(); nil != e {
    fmt.Printf("ERROR: %v\n", e)
}
</code></pre>

<p>这个代码会一直等到<code>sleep 100</code>完成后才退出, 与常识不符.</p>

<p>但去掉Stdout重定向后, 代码就不会等待卡住</p>

<pre><code>c := exec.Command("sh", "-c", "sleep 100 &amp;")
if e := c.Start(); nil != e {
    fmt.Printf("ERROR: %v\n", e)
}
if e := c.Wait(); nil != e {
    fmt.Printf("ERROR: %v\n", e)
}
</code></pre>

<p>在运行时打出stacktrace, 再翻翻GO的源代码, 发现GO卡在以下代码</p>

<pre><code>func (c *Cmd) Wait() error {
    ...
    state, err := c.Process.Wait()
    ...
    var copyError error
    for _ = range c.goroutine {
        if err := &lt;-c.errch; err != nil &amp;&amp; copyError == nil {
            copyError = err
        }
    }
    ...
}
</code></pre>

<p>可以看到<code>Wait()</code>在等待Process结束后, 还等待了所有<code>c.goroutine</code>的<code>c.errch</code>信号. 参看以下代码:</p>

<pre><code>func (c *Cmd) stdout() (f *os.File, err error) {
    return c.writerDescriptor(c.Stdout)
}

func (c *Cmd) writerDescriptor(w io.Writer) (f *os.File, err error) {
    ...
    c.goroutine = append(c.goroutine, func() error {
        _, err := io.Copy(w, pr)
        return err
    })
    ...
}
</code></pre>

<p>重定向<code>stdout</code>时, 会添加一个监听任务到<code>goroutine</code> (<code>stderr</code>也是同理)</p>

<p>结论是由于将<code>sleep 100</code>放到后台执行, 其进程<code>stdout</code>并没有关闭, <code>io.Copy()</code>不会返回, 所以会卡住</p>

<p>临时的解决方法就是将后台进程的<code>stdout</code>和<code>stderr</code>重定向出去, 以下代码不会卡住:</p>

<pre><code>c := exec.Command("sh", "-c", "sleep 100 &gt;/dev/null 2&gt;/dev/null &amp;")
var b bytes.Buffer
c.Stdout = &amp;b

if e := c.Start(); nil != e {
    fmt.Printf("ERROR: %v\n", e)
}
if e := c.Wait(); nil != e {
    fmt.Printf("ERROR: %v\n", e)
}
</code></pre>

<p>已经报了<a href="https://code.google.com/p/go/issues/detail?id=7378&amp;thanks=7378&amp;ts=1392967848">bug</a></p>

<p>但想不出好的GO代码的修改方案</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[栽在Go中for的变量]]></title>
    <link href="http://ikarishinjieva.github.com/blog/blog/2013/12/26/go-iterate-variable/"/>
    <updated>2013-12-26T22:13:00+08:00</updated>
    <id>http://ikarishinjieva.github.com/blog/blog/2013/12/26/go-iterate-variable</id>
    <content type="html"><![CDATA[<p>我是万没料到自己栽在了go的for上，说多了都是眼泪</p>

<p>``` go
type testStruct struct {</p>

<pre><code> no int
</code></pre>

<p>}</p>

<p>func main() {</p>

<pre><code> a := []testStruct{testStruct{1}, testStruct{2}, testStruct{3}}
 var p *testStruct
 for _, i := range a {
      if i.no == 2 {
           // o := i
           // p = &amp;o
           p = &amp;i
      }
 }
 fmt.Println(p.no)
</code></pre>

<p>}
```</p>

<p>猜猜看输出是多少？<a href="http://play.golang.org/p/OzkxuYIboc">试试看吧</a></p>

<p>理解起来很容易，<code>p</code>取得是<code>i</code>的地址，而<strong>range循环变量<code>i</code>在每个循环之间都是复用同一个地址</strong></p>

<p>证明一下，<a href="http://play.golang.org/p/b3QFcoh35Q">试试看？</a></p>

<p>```go
a := []int{1, 2, 3, 4, 5}
for _, item := range a {</p>

<pre><code> fmt.Printf("%p\n", &amp;item)
</code></pre>

<p>}
```</p>

<p>虽然很容易理解，也很容易掉坑，尤其for上用<code>:=</code>，那感觉就像js里连续用<code>var</code>，除了第一下剩下的都不好使...</p>
]]></content>
  </entry>
  
</feed>
