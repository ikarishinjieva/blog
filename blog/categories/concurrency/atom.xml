<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: concurrency | Tac say]]></title>
  <link href="http://ikarishinjieva.github.com/blog/blog/categories/concurrency/atom.xml" rel="self"/>
  <link href="http://ikarishinjieva.github.com/blog/"/>
  <updated>2014-02-22T10:59:17+08:00</updated>
  <id>http://ikarishinjieva.github.com/blog/</id>
  <author>
    <name><![CDATA[Tac Huang (ikari_shinji@github)]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[读写锁-读可重入]]></title>
    <link href="http://ikarishinjieva.github.com/blog/blog/2013/03/14/read-write-lock-read-reentrant/"/>
    <updated>2013-03-14T21:37:00+08:00</updated>
    <id>http://ikarishinjieva.github.com/blog/blog/2013/03/14/read-write-lock-read-reentrant</id>
    <content type="html"><![CDATA[<p>发现<a href="http://tutorials.jenkov.com/java-concurrency/read-write-locks.html">这篇文献</a>描写读写锁和可重入性非常具体。</p>

<p>尝试实现文章中的读可重入的读写锁：</p>

<p>考虑如何测试一个读可重入的读写锁, 由于读写锁的性质(可以同时存在多个读锁), 如果只是在线程A连续申请两个读锁, 就无法证明是锁的重入性发挥了作用。</p>

<p>测试思路是先在线程A申请读锁, 然后在线程B申请写锁, 若在线程C申请读锁, 此读锁应阻塞。而如果在线程A申请另一个读锁(前一个未释放), 线程A不应被阻塞。</p>

<p>{% codeblock 测试代码(我的确用了Main来测试...) lang:java %}
public static void main(String[] args) throws InterruptedException {</p>

<pre><code>final ReadWriteLockReadReentrant lock = new ReadWriteLockReadReentrant();

new Thread() {
    @Override
    public void run() {
        try {
            lock.lockRead();
            System.out.println("Reading");
            sleep(5000);
            System.out.println("Inner Reading");
            lock.lockRead();
        } catch (InterruptedException e) {

        } finally {
            System.out.println("Inner Reading End");
            lock.unlockRead();
            System.out.println("Reading End");
            lock.unlockRead();
        }
    }
}.start();
Thread.sleep(500);

new Thread() {
    @Override
    public void run() {
        try {
            System.out.println("Request write lock");
            lock.lockWrite();
            System.out.println("Writing");
        } catch (InterruptedException e) {

        } finally {
            System.out.println("Writing End");
            lock.unlockWrite();
        }
    }
}.start();
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>结果应当是：Reading(线程A),Request write lock(线程B),Inner Reading(未阻塞),Inner Reading End,Reading End,Writing,Writing End</p>

<p>{% codeblock 读重入的读写锁(基本是抄上面文献的代码~) lang:java %}
import java.util.HashMap;
import java.util.Map;</p>

<p>public class ReadWriteLockReadReentrant {</p>

<pre><code>private boolean hasWriter = false;
private int writeRequests = 0;
private Map&lt;Thread, Integer&gt; readers = new HashMap&lt;Thread, Integer&gt;();

public synchronized void lockRead() throws InterruptedException {
    Thread current = Thread.currentThread();
    while (!couldRead(current)) {
        wait();
    }
    readers.put(current, getReaders(current) + 1);
}

private int getReaders(Thread current) {
    if (!readers.containsKey(current)) {
        return 0;
    }
    return readers.get(current);
}

private boolean couldRead(Thread current) {
    if (hasWriter) {
        return false;
    }
    if (readers.containsKey(current)) {
        return true; //important
    }
    if (writeRequests &gt; 0) {
        return false;
    }
    return true;
}

public synchronized void unlockRead() {
    Thread current = Thread.currentThread();
    setReaders(current, getReaders(current) - 1);
    notifyAll();
}

private void setReaders(Thread current, Integer now) {
    if (now == 0) {
        readers.remove(current);
    } else {
        readers.put(current, now);
    }
}

public synchronized void lockWrite() throws InterruptedException {
    writeRequests++;
    while (readers.size() &gt; 0) {
        wait();
    }
    writeRequests--;
    hasWriter = true;
}


public synchronized void unlockWrite() {
    hasWriter = false;
    notifyAll();
}
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>需要注意的是标记"//important"的那行，如果这个判断和writeRequest的判断互换位置，线程B申请写锁被阻塞时，线程A无法申请到第二个读锁。一切就悲剧了。</p>

<p>{% codeblock 标记为"//important"的判断和writeRequest的判断互换位置 lang:java %}
private boolean couldRead(Thread current) {</p>

<pre><code>if (hasWriter) {
    return false;
}
if (writeRequests &gt; 0) {
    return false;
}
if (readers.containsKey(current)) {
    return true; //important
}
return true;
</code></pre>

<p>}
{% endcodeblock %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[可重入Lock]]></title>
    <link href="http://ikarishinjieva.github.com/blog/blog/2013/03/13/reentrant-lock/"/>
    <updated>2013-03-13T23:01:00+08:00</updated>
    <id>http://ikarishinjieva.github.com/blog/blog/2013/03/13/reentrant-lock</id>
    <content type="html"><![CDATA[<p>参考：<a href="http://book.douban.com/subject/10484692/">Java并发编程实践</a></p>

<p>参考书里2.3.2对锁的重入性一句话搞定：“获取所得粒度是"线程"，而不是"调用"”</p>

<p>下面的代码验证内置锁(synchronize)和Lock(ReentrantLock)的重入性</p>

<p>{% codeblock 内置锁可重入 lang:java %}
public class Reentrant {</p>

<pre><code>public void method1() {
    synchronized (Reentrant.class) {
        System.out.println("method1 run");
        method2();
    }
}

public void method2() {
    synchronized (Reentrant.class) {
        System.out.println("method2 run in method1");
    }
}

public static void main(String[] args) {
    new Reentrant().method1();
}
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>{% codeblock Lock对象可重入 lang:java %}
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;</p>

<p>public class Reentrant2 {</p>

<pre><code>private Lock lock = new ReentrantLock();

public void method1() {
    lock.lock();
    try {
        System.out.println("method1 run");
        method2();
    } finally {
        lock.unlock();
    }
}

public void method2() {
    lock.lock();
    try {
        System.out.println("method2 run in method1");
    } finally {
        lock.unlock();
    }
}

public static void main(String[] args) {
    new Reentrant2().method1();
}
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>在同一线程里，method1调用持同样锁的method2，不会等锁。这就是锁的"重入"。</p>

<p>{% codeblock 不同线程里锁不可重入 lang:java %}
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;</p>

<p>public class Reentrant3 {</p>

<pre><code>private static Lock lock = new ReentrantLock();

private static class T1 extends Thread {
    @Override
    public void run() {
        System.out.println("Thread 1 start");
        lock.lock();
        try {
            Thread.sleep(10000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
        System.out.println("Thread 1 end");
    }
}

private static class T2 extends Thread {
    @Override
    public void run() {
        System.out.println("Thread 2 start");
        lock.lock();
        lock.unlock();
        System.out.println("Thread 2 end");
    }
}


public static void main(String[] args) {
    new T1().start();
    Thread.sleep(100);
    new T2().start();
}
</code></pre>

<p>}
{% endcodeblock %}
不同线程可以看到T2一定会等到T1释放锁之后。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Thread Notify 和 NotifyAll]]></title>
    <link href="http://ikarishinjieva.github.com/blog/blog/2013/03/13/notify-and-notify-all/"/>
    <updated>2013-03-13T21:47:00+08:00</updated>
    <id>http://ikarishinjieva.github.com/blog/blog/2013/03/13/notify-and-notify-all</id>
    <content type="html"><![CDATA[<p>参考：<a href="http://blog.csdn.net/iceman1952/article/details/2159812">http://blog.csdn.net/iceman1952/article/details/2159812</a></p>

<p>{% codeblock notify lang:java %}
public class Notify {</p>

<pre><code>private static class T extends Thread {
    public T(String s) {
        super(s);
    }

    @Override
    public void run() {
        System.out.println(String.format("%s run.", this.getName()));
        synchronized (Notify.class) {
            try {
                Notify.class.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        System.out.println(String.format("%s done.", this.getName()));
    }
}

public static void main(String[] args) throws InterruptedException {
    new T("thread 1").start();
    new T("thread 2").start();
    Thread.sleep(1000);
    System.out.println("notify");
    synchronized (Notify.class) {
        Notify.class.notify();
        //Notify.class.notifyAll(); //alternative
    }
}
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>Notify版本主线程是不会退出的，因为释放了一个wait，另一个就会等到天荒地老。</p>

<p>NotifyAll主线程会退出。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Thread wait 和 sleep]]></title>
    <link href="http://ikarishinjieva.github.com/blog/blog/2013/03/11/thread-wait-sleep/"/>
    <updated>2013-03-11T22:32:00+08:00</updated>
    <id>http://ikarishinjieva.github.com/blog/blog/2013/03/11/thread-wait-sleep</id>
    <content type="html"><![CDATA[<p>ifeve上发现几个多线程的<a href="http://ifeve.com/javaconcurrency-interview-questions-base/">基础问题</a>。我一直不写多线程（我这两年到底都写了些什么~），重头学起。</p>

<p>sleep和wait的区别。sleep让出cpu，等一段时间，重新进入竞争，不释放锁。wait等一个状态notify，才重新进入竞争，但释放锁。</p>

<p>下面代码说明是否释放锁的区别：</p>

<p>{% codeblock sleep不会释放锁 lang:java %}
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;</p>

<p>public class MultiThread {</p>

<pre><code>public static class T1 extends Thread {
    @Override
    public void run() {
        synchronized (MultiThread.class) {
            System.out.println("T1 run");
            System.out.println("T1 sleep");
            try {
                sleep(10000);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
            System.out.println("T1 wake up");
        }
    }
}

public static class T2 extends Thread {
    @Override
    public void run() {
        synchronized (MultiThread.class) {
            System.out.println("T2 run");
        }
    }
}

public static void main(final String[] args) throws InterruptedException {
    ExecutorService executorService = Executors.newFixedThreadPool(2);
    executorService.execute(new T1());
    Thread.sleep(1000);
    executorService.execute(new T2());

    //dispose
    executorService.awaitTermination(1, TimeUnit.HOURS);
}
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>{% codeblock wait会释放锁 lang:java %}
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;</p>

<p>public class MultiThread2 {</p>

<pre><code>public static class T1 extends Thread {
    @Override
    public void run() {
        synchronized (MultiThread2.class) {
            System.out.println("T1 run");
            System.out.println("T1 wait");
            try {
                MultiThread2.class.wait();
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
            System.out.println("T1 wake up");
        }
    }
}

public static class T2 extends Thread {
    @Override
    public void run() {
        synchronized (MultiThread2.class) {
            System.out.println("T2 run");
        }
    }
}

public static void main(final String[] args) throws InterruptedException {
    ExecutorService executorService = Executors.newFixedThreadPool(2);
    executorService.execute(new T1());
    Thread.sleep(1000);
    executorService.execute(new T2());

    //dispose
    Thread.sleep(10000);
    synchronized (MultiThread2.class) {
        MultiThread2.class.notify();
    }
    executorService.awaitTermination(1, TimeUnit.HOURS);
}
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>sleep的执行结果是T1 run, T1 sleep, T1 wake up, T2 run</p>

<p>wait的执行结果是T1 run, T1 wait, T2 run (此处锁被释放, T2获得锁), T1 wake up</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[False Sharing 阅读]]></title>
    <link href="http://ikarishinjieva.github.com/blog/blog/2013/03/10/false-sharing-0/"/>
    <updated>2013-03-10T23:40:00+08:00</updated>
    <id>http://ikarishinjieva.github.com/blog/blog/2013/03/10/false-sharing-0</id>
    <content type="html"><![CDATA[<p>应该说<a href="http://ifeve.com/disruptor-cacheline-padding/">这篇</a>和<a href="http://ifeve.com/false-sharing/">这篇文章</a>是最近读的最有意思的一篇文章，关于多线程访问时，内存预读到寄存器的内容产生的数据竞争(false sharing)对性能的影响(我已经不知道我在说什么了，文章里解释的很清楚)。</p>

<p>重做了第二篇里的试验，发现六个padding不够，需要七个padding(p7)才能有两倍的性能差异。(没有文献里说的那么离谱，测试环境的差异吧)
{% codeblock lang:java %}
public long p1, p2, p3, p4, p5, p6; // comment out
{% endcodeblock %}</p>

<p><del>TODO：了解第七个padding的来源</del></p>

<p>看了第二篇文章的<a href="http://ifeve.com/false-shareing-java-7-cn/">更新篇</a>, 用这个稳定的代码跑测试，就不会有之前p7的问题。（可能是之前p1-p6被优化掉了？不解。）</p>

<p>在公司八核的机器上也测过，性能提升也就在2-4倍左右。没有那么夸张。</p>

<p>原理基本清楚，对不同平台间的差异完全没想法。不做深入了解。</p>
]]></content>
  </entry>
  
</feed>
