<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: notify | Tac say]]></title>
  <link href="http://ikarishinjieva.github.com/blog/blog/categories/notify/atom.xml" rel="self"/>
  <link href="http://ikarishinjieva.github.com/blog/"/>
  <updated>2014-02-22T10:59:17+08:00</updated>
  <id>http://ikarishinjieva.github.com/blog/</id>
  <author>
    <name><![CDATA[Tac Huang (ikari_shinji@github)]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[可重入Lock]]></title>
    <link href="http://ikarishinjieva.github.com/blog/blog/2013/03/13/reentrant-lock/"/>
    <updated>2013-03-13T23:01:00+08:00</updated>
    <id>http://ikarishinjieva.github.com/blog/blog/2013/03/13/reentrant-lock</id>
    <content type="html"><![CDATA[<p>参考：<a href="http://book.douban.com/subject/10484692/">Java并发编程实践</a></p>

<p>参考书里2.3.2对锁的重入性一句话搞定：“获取所得粒度是"线程"，而不是"调用"”</p>

<p>下面的代码验证内置锁(synchronize)和Lock(ReentrantLock)的重入性</p>

<p>{% codeblock 内置锁可重入 lang:java %}
public class Reentrant {</p>

<pre><code>public void method1() {
    synchronized (Reentrant.class) {
        System.out.println("method1 run");
        method2();
    }
}

public void method2() {
    synchronized (Reentrant.class) {
        System.out.println("method2 run in method1");
    }
}

public static void main(String[] args) {
    new Reentrant().method1();
}
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>{% codeblock Lock对象可重入 lang:java %}
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;</p>

<p>public class Reentrant2 {</p>

<pre><code>private Lock lock = new ReentrantLock();

public void method1() {
    lock.lock();
    try {
        System.out.println("method1 run");
        method2();
    } finally {
        lock.unlock();
    }
}

public void method2() {
    lock.lock();
    try {
        System.out.println("method2 run in method1");
    } finally {
        lock.unlock();
    }
}

public static void main(String[] args) {
    new Reentrant2().method1();
}
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>在同一线程里，method1调用持同样锁的method2，不会等锁。这就是锁的"重入"。</p>

<p>{% codeblock 不同线程里锁不可重入 lang:java %}
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;</p>

<p>public class Reentrant3 {</p>

<pre><code>private static Lock lock = new ReentrantLock();

private static class T1 extends Thread {
    @Override
    public void run() {
        System.out.println("Thread 1 start");
        lock.lock();
        try {
            Thread.sleep(10000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
        System.out.println("Thread 1 end");
    }
}

private static class T2 extends Thread {
    @Override
    public void run() {
        System.out.println("Thread 2 start");
        lock.lock();
        lock.unlock();
        System.out.println("Thread 2 end");
    }
}


public static void main(String[] args) {
    new T1().start();
    Thread.sleep(100);
    new T2().start();
}
</code></pre>

<p>}
{% endcodeblock %}
不同线程可以看到T2一定会等到T1释放锁之后。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Thread Notify 和 NotifyAll]]></title>
    <link href="http://ikarishinjieva.github.com/blog/blog/2013/03/13/notify-and-notify-all/"/>
    <updated>2013-03-13T21:47:00+08:00</updated>
    <id>http://ikarishinjieva.github.com/blog/blog/2013/03/13/notify-and-notify-all</id>
    <content type="html"><![CDATA[<p>参考：<a href="http://blog.csdn.net/iceman1952/article/details/2159812">http://blog.csdn.net/iceman1952/article/details/2159812</a></p>

<p>{% codeblock notify lang:java %}
public class Notify {</p>

<pre><code>private static class T extends Thread {
    public T(String s) {
        super(s);
    }

    @Override
    public void run() {
        System.out.println(String.format("%s run.", this.getName()));
        synchronized (Notify.class) {
            try {
                Notify.class.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        System.out.println(String.format("%s done.", this.getName()));
    }
}

public static void main(String[] args) throws InterruptedException {
    new T("thread 1").start();
    new T("thread 2").start();
    Thread.sleep(1000);
    System.out.println("notify");
    synchronized (Notify.class) {
        Notify.class.notify();
        //Notify.class.notifyAll(); //alternative
    }
}
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>Notify版本主线程是不会退出的，因为释放了一个wait，另一个就会等到天荒地老。</p>

<p>NotifyAll主线程会退出。</p>
]]></content>
  </entry>
  
</feed>
