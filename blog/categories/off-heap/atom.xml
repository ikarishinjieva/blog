<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: off-heap | Tac say]]></title>
  <link href="http://ikarishinjieva.github.com/blog/blog/categories/off-heap/atom.xml" rel="self"/>
  <link href="http://ikarishinjieva.github.com/blog/"/>
  <updated>2014-02-22T10:59:17+08:00</updated>
  <id>http://ikarishinjieva.github.com/blog/</id>
  <author>
    <name><![CDATA[Tac Huang (ikari_shinji@github)]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Java off-heap的一些参考]]></title>
    <link href="http://ikarishinjieva.github.com/blog/blog/2013/05/18/java-offheap-memory/"/>
    <updated>2013-05-18T23:00:00+08:00</updated>
    <id>http://ikarishinjieva.github.com/blog/blog/2013/05/18/java-offheap-memory</id>
    <content type="html"><![CDATA[<p>读了Hazelcast的文档，很有意思的部分是"Elastic Memory"，为了减少GC，用到了java off-heap(off-heap允许Java直接操作内存空间, 类似于C的malloc和free)。之前孤陋寡闻，记录一些off-heap的参考。</p>

<p>1.做了以下对比试验，来对比Heap和Non-heap
{% codeblock Heap lang:java %}
public class HeapAllocation {</p>

<pre><code>public static void main(String[] args) {
    while (true) {
        Integer[] a = new Integer[1000000];
    }
}
</code></pre>

<p>}
{% endcodeblock %}
{% codeblock Off-heap lang:java %}
import java.lang.reflect.Field;</p>

<p>public class OffHeapAllocation {</p>

<pre><code>private static Unsafe unsafe;

static {
    try {
        Field field = Unsafe.class.getDeclaredField("theUnsafe");
        field.setAccessible(true);
        unsafe = (Unsafe)field.get(null);
    } catch(Exception e) {
    }
}

public static void main(String[] args) {
    while (true) {
        long addr = unsafe.allocateMemory(8 * 1000000);
        unsafe.freeMemory(addr);
    }
}
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>Heap GC的测试结果：
{% img /images/2013-05-18-java-offheap-memory-0.png Heap %}</p>

<p>Off-heap GC的测试结果：
{% img /images/2013-05-18-java-offheap-memory-1.png Off-heap %}</p>

<p>尽管这种测试没啥意义，只能给个直观感受，还是可以看到Heap GC Pause Time还是很多的。</p>

<p>2.<a href="http://mentablog.soliveirajr.com/2012/11/which-one-is-faster-java-heap-or-native-memory">这篇文章</a> 对off-heap的性能做了全面的对比。</p>

<p>结论是heap access要快于off-heap，但off-heap在躲开GC pause和开大内存的时候明显优秀。</p>

<p>有趣的是在评论一楼Peter Lawrey指出JIT会影响这个测试，于是作者重做测试以证明JIT不影响结论。</p>

<p>3.<a href="http://mentablog.soliveirajr.com/2012/11/real-time-java-programming-without-gc">这篇文章</a> 讨论了如何让Java避开GC并提供了memory的测试类GCUtils。</p>

<p>4.<a href="http://stackoverflow.com/questions/12246533/where-to-find-the-evidence-of-how-to-calculate-the-size-of-a-java-object">在这里</a> Peter Lawrey谈到了如何测量一个Java对象的大小和TLAB对测量的影响。仅供参考。</p>
]]></content>
  </entry>
  
</feed>
