<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: timeout | Tac say]]></title>
  <link href="http://ikarishinjieva.github.com/blog/blog/categories/timeout/atom.xml" rel="self"/>
  <link href="http://ikarishinjieva.github.com/blog/"/>
  <updated>2014-04-10T22:48:55+08:00</updated>
  <id>http://ikarishinjieva.github.com/blog/</id>
  <author>
    <name><![CDATA[Tac Huang (ikari_shinji@github)]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[jruby中tcp阻塞时Timeout::timeout失效]]></title>
    <link href="http://ikarishinjieva.github.com/blog/blog/2014/01/08/jruby-bug-tcp-timeout/"/>
    <updated>2014-01-08T23:04:00+08:00</updated>
    <id>http://ikarishinjieva.github.com/blog/blog/2014/01/08/jruby-bug-tcp-timeout</id>
    <content type="html"><![CDATA[<h3>问题场景</h3>

<p>首先有一台tcp server, 模拟一个黑洞</p>

<p>``` ruby
require 'socket'</p>

<p>tcp_server = TCPServer.new("0.0.0.0", 6666)</p>

<p>loop do</p>

<pre><code> socket = tcp_server.accept
 puts 'got conn']
 #blackhole
</code></pre>

<p>end
```</p>

<p>然后发起一个connection, 从server接受消息(很显然会阻塞在recv上), 并用<code>Timeout::timeout</code>设置一个超时时间</p>

<p>``` ruby
require "socket"
require "timeout"</p>

<p>sock = Socket.new(Socket::AF_INET, Socket::SOCK_STREAM, 0)
addr = Socket.sockaddr_in(6666, "127.0.0.1")
sock.connect(addr)</p>

<p>Timeout::timeout(5) {</p>

<pre><code> sock.recv(1)
</code></pre>

<p>}
```</p>

<p>上面这个场景如果在ruby上跑,5秒后会超时,但如果使用jruby(1.7.6)就会一直处于阻塞</p>

<h3>解决方案</h3>

<p>使用非阻塞<code>recv</code>,可以在jruby上正常运行</p>

<p>``` ruby
require "socket"
require "timeout"</p>

<p>sock = Socket.new(Socket::AF_INET, Socket::SOCK_STREAM, 0)
addr = Socket.sockaddr_in(6666, "127.0.0.1")
sock.connect(addr)</p>

<p>Timeout::timeout(5) {</p>

<pre><code>begin
    sock.recv_nonblock(1)
rescue IO::WaitReadable
    IO.select([sock],nil,nil,5)
    retry
end
</code></pre>

<p>}
```</p>

<h3>猜测</h3>

<p>查看一下ruby <code>timeout.rb</code>的源码</p>

<p>```ruby
  begin</p>

<pre><code>x = Thread.current
y = Thread.start {
  begin
    sleep sec
  rescue =&gt; e
    x.raise e
  else
    x.raise exception, "execution expired"
  end
}
return yield(sec)
</code></pre>

<p>  ensure</p>

<pre><code>if y
  y.kill
  y.join # make sure y is dead.
end
</code></pre>

<p>  end
```</p>

<p>大概看到timeout是起了一个计时线程,超时时向主线程发起exception</p>

<p>猜测是因为jvm的线程模型导致exception不能向阻塞线程提交,但有待验证</p>
]]></content>
  </entry>
  
</feed>
