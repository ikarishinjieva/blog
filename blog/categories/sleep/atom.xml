<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: sleep | Tac say]]></title>
  <link href="http://ikarishinjieva.github.com/blog/blog/categories/sleep/atom.xml" rel="self"/>
  <link href="http://ikarishinjieva.github.com/blog/"/>
  <updated>2014-02-22T10:59:17+08:00</updated>
  <id>http://ikarishinjieva.github.com/blog/</id>
  <author>
    <name><![CDATA[Tac Huang (ikari_shinji@github)]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Thread wait 和 sleep]]></title>
    <link href="http://ikarishinjieva.github.com/blog/blog/2013/03/11/thread-wait-sleep/"/>
    <updated>2013-03-11T22:32:00+08:00</updated>
    <id>http://ikarishinjieva.github.com/blog/blog/2013/03/11/thread-wait-sleep</id>
    <content type="html"><![CDATA[<p>ifeve上发现几个多线程的<a href="http://ifeve.com/javaconcurrency-interview-questions-base/">基础问题</a>。我一直不写多线程（我这两年到底都写了些什么~），重头学起。</p>

<p>sleep和wait的区别。sleep让出cpu，等一段时间，重新进入竞争，不释放锁。wait等一个状态notify，才重新进入竞争，但释放锁。</p>

<p>下面代码说明是否释放锁的区别：</p>

<p>{% codeblock sleep不会释放锁 lang:java %}
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;</p>

<p>public class MultiThread {</p>

<pre><code>public static class T1 extends Thread {
    @Override
    public void run() {
        synchronized (MultiThread.class) {
            System.out.println("T1 run");
            System.out.println("T1 sleep");
            try {
                sleep(10000);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
            System.out.println("T1 wake up");
        }
    }
}

public static class T2 extends Thread {
    @Override
    public void run() {
        synchronized (MultiThread.class) {
            System.out.println("T2 run");
        }
    }
}

public static void main(final String[] args) throws InterruptedException {
    ExecutorService executorService = Executors.newFixedThreadPool(2);
    executorService.execute(new T1());
    Thread.sleep(1000);
    executorService.execute(new T2());

    //dispose
    executorService.awaitTermination(1, TimeUnit.HOURS);
}
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>{% codeblock wait会释放锁 lang:java %}
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;</p>

<p>public class MultiThread2 {</p>

<pre><code>public static class T1 extends Thread {
    @Override
    public void run() {
        synchronized (MultiThread2.class) {
            System.out.println("T1 run");
            System.out.println("T1 wait");
            try {
                MultiThread2.class.wait();
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
            System.out.println("T1 wake up");
        }
    }
}

public static class T2 extends Thread {
    @Override
    public void run() {
        synchronized (MultiThread2.class) {
            System.out.println("T2 run");
        }
    }
}

public static void main(final String[] args) throws InterruptedException {
    ExecutorService executorService = Executors.newFixedThreadPool(2);
    executorService.execute(new T1());
    Thread.sleep(1000);
    executorService.execute(new T2());

    //dispose
    Thread.sleep(10000);
    synchronized (MultiThread2.class) {
        MultiThread2.class.notify();
    }
    executorService.awaitTermination(1, TimeUnit.HOURS);
}
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>sleep的执行结果是T1 run, T1 sleep, T1 wake up, T2 run</p>

<p>wait的执行结果是T1 run, T1 wait, T2 run (此处锁被释放, T2获得锁), T1 wake up</p>
]]></content>
  </entry>
  
</feed>
