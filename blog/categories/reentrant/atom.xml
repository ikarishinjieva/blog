<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: reentrant | Tac say]]></title>
  <link href="http://ikarishinjieva.github.com/blog/blog/categories/reentrant/atom.xml" rel="self"/>
  <link href="http://ikarishinjieva.github.com/blog/"/>
  <updated>2014-02-22T10:59:17+08:00</updated>
  <id>http://ikarishinjieva.github.com/blog/</id>
  <author>
    <name><![CDATA[Tac Huang (ikari_shinji@github)]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[读写锁-读可重入]]></title>
    <link href="http://ikarishinjieva.github.com/blog/blog/2013/03/14/read-write-lock-read-reentrant/"/>
    <updated>2013-03-14T21:37:00+08:00</updated>
    <id>http://ikarishinjieva.github.com/blog/blog/2013/03/14/read-write-lock-read-reentrant</id>
    <content type="html"><![CDATA[<p>发现<a href="http://tutorials.jenkov.com/java-concurrency/read-write-locks.html">这篇文献</a>描写读写锁和可重入性非常具体。</p>

<p>尝试实现文章中的读可重入的读写锁：</p>

<p>考虑如何测试一个读可重入的读写锁, 由于读写锁的性质(可以同时存在多个读锁), 如果只是在线程A连续申请两个读锁, 就无法证明是锁的重入性发挥了作用。</p>

<p>测试思路是先在线程A申请读锁, 然后在线程B申请写锁, 若在线程C申请读锁, 此读锁应阻塞。而如果在线程A申请另一个读锁(前一个未释放), 线程A不应被阻塞。</p>

<p>{% codeblock 测试代码(我的确用了Main来测试...) lang:java %}
public static void main(String[] args) throws InterruptedException {</p>

<pre><code>final ReadWriteLockReadReentrant lock = new ReadWriteLockReadReentrant();

new Thread() {
    @Override
    public void run() {
        try {
            lock.lockRead();
            System.out.println("Reading");
            sleep(5000);
            System.out.println("Inner Reading");
            lock.lockRead();
        } catch (InterruptedException e) {

        } finally {
            System.out.println("Inner Reading End");
            lock.unlockRead();
            System.out.println("Reading End");
            lock.unlockRead();
        }
    }
}.start();
Thread.sleep(500);

new Thread() {
    @Override
    public void run() {
        try {
            System.out.println("Request write lock");
            lock.lockWrite();
            System.out.println("Writing");
        } catch (InterruptedException e) {

        } finally {
            System.out.println("Writing End");
            lock.unlockWrite();
        }
    }
}.start();
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>结果应当是：Reading(线程A),Request write lock(线程B),Inner Reading(未阻塞),Inner Reading End,Reading End,Writing,Writing End</p>

<p>{% codeblock 读重入的读写锁(基本是抄上面文献的代码~) lang:java %}
import java.util.HashMap;
import java.util.Map;</p>

<p>public class ReadWriteLockReadReentrant {</p>

<pre><code>private boolean hasWriter = false;
private int writeRequests = 0;
private Map&lt;Thread, Integer&gt; readers = new HashMap&lt;Thread, Integer&gt;();

public synchronized void lockRead() throws InterruptedException {
    Thread current = Thread.currentThread();
    while (!couldRead(current)) {
        wait();
    }
    readers.put(current, getReaders(current) + 1);
}

private int getReaders(Thread current) {
    if (!readers.containsKey(current)) {
        return 0;
    }
    return readers.get(current);
}

private boolean couldRead(Thread current) {
    if (hasWriter) {
        return false;
    }
    if (readers.containsKey(current)) {
        return true; //important
    }
    if (writeRequests &gt; 0) {
        return false;
    }
    return true;
}

public synchronized void unlockRead() {
    Thread current = Thread.currentThread();
    setReaders(current, getReaders(current) - 1);
    notifyAll();
}

private void setReaders(Thread current, Integer now) {
    if (now == 0) {
        readers.remove(current);
    } else {
        readers.put(current, now);
    }
}

public synchronized void lockWrite() throws InterruptedException {
    writeRequests++;
    while (readers.size() &gt; 0) {
        wait();
    }
    writeRequests--;
    hasWriter = true;
}


public synchronized void unlockWrite() {
    hasWriter = false;
    notifyAll();
}
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>需要注意的是标记"//important"的那行，如果这个判断和writeRequest的判断互换位置，线程B申请写锁被阻塞时，线程A无法申请到第二个读锁。一切就悲剧了。</p>

<p>{% codeblock 标记为"//important"的判断和writeRequest的判断互换位置 lang:java %}
private boolean couldRead(Thread current) {</p>

<pre><code>if (hasWriter) {
    return false;
}
if (writeRequests &gt; 0) {
    return false;
}
if (readers.containsKey(current)) {
    return true; //important
}
return true;
</code></pre>

<p>}
{% endcodeblock %}</p>
]]></content>
  </entry>
  
</feed>
