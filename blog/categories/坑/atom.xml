<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 坑 | Tac say]]></title>
  <link href="http://ikarishinjieva.github.com/blog/blog/categories/坑/atom.xml" rel="self"/>
  <link href="http://ikarishinjieva.github.com/blog/"/>
  <updated>2014-06-15T11:23:47+08:00</updated>
  <id>http://ikarishinjieva.github.com/blog/</id>
  <author>
    <name><![CDATA[Tac Huang (ikari_shinji@github)]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[golang, cmd会泄露文件句柄]]></title>
    <link href="http://ikarishinjieva.github.com/blog/blog/2014/03/25/go-leak-fd/"/>
    <updated>2014-03-25T22:34:00+08:00</updated>
    <id>http://ikarishinjieva.github.com/blog/blog/2014/03/25/go-leak-fd</id>
    <content type="html"><![CDATA[<p>在go中用<code>cmd</code>生成新的process时, 在某些os中(包括linux的某些版本), 父进程的文件句柄会泄露到子进程中, 参看代码</p>

<pre><code>package main

import (
    "fmt"
    "os"
    "os/exec"
)

func main() {
    a, _ := os.OpenFile("1", os.O_CREATE|os.O_RDWR, 0755)
    defer a.Close()
    cmd := exec.Command("sh", "-c", "lsof +D .; sleep 3")
    output, _ := cmd.CombinedOutput()
    fmt.Printf("%v\n", string(output))
}
</code></pre>

<p>得到输出</p>

<pre><code>[root@GroupH-HA-1 tmp]# uname -a
Linux GroupH-HA-1 2.6.18-194.el5xen #1 SMP Tue Mar 16 22:01:26 EDT 2010 x86_64 x86_64 x86_64 GNU/Linux
[root@GroupH-HA-1 tmp]# ./main
COMMAND  PID USER   FD   TYPE DEVICE    SIZE    NODE NAME
bash    4693 root  cwd    DIR  253,0   32768 3506177 .
main    6184 root  cwd    DIR  253,0   32768 3506177 .
main    6184 root  txt    REG  253,0 2250464 3506237 ./main
main    6184 root    3u   REG  253,0       0 3506238 ./1
sh      6189 root  cwd    DIR  253,0   32768 3506177 .
sh      6189 root    3u   REG  253,0       0 3506238 ./1
lsof    6190 root  cwd    DIR  253,0   32768 3506177 .
lsof    6191 root  cwd    DIR  253,0   32768 3506177 .
</code></pre>

<p>可以看到<code>./1</code>的文件句柄泄漏到了<code>sh -c</code>中, 目前为止没有特别好的解决方案</p>

<p>参看<a href="https://code.google.com/p/go/issues/detail?id=2603">此处bug描述</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[GO exec.command.Wait 执行后台程序,在重定向输出时卡住]]></title>
    <link href="http://ikarishinjieva.github.com/blog/blog/2014/02/22/go-exec-command-block-when-redirect-stdout/"/>
    <updated>2014-02-22T10:30:00+08:00</updated>
    <id>http://ikarishinjieva.github.com/blog/blog/2014/02/22/go-exec-command-block-when-redirect-stdout</id>
    <content type="html"><![CDATA[<p>在GO上发现以下现象</p>

<pre><code>c := exec.Command("sh", "-c", "sleep 100 &amp;")
var b bytes.Buffer
c.Stdout = &amp;b

if e := c.Start(); nil != e {
    fmt.Printf("ERROR: %v\n", e)
}
if e := c.Wait(); nil != e {
    fmt.Printf("ERROR: %v\n", e)
}
</code></pre>

<p>这个代码会一直等到<code>sleep 100</code>完成后才退出, 与常识不符.</p>

<p>但去掉Stdout重定向后, 代码就不会等待卡住</p>

<pre><code>c := exec.Command("sh", "-c", "sleep 100 &amp;")
if e := c.Start(); nil != e {
    fmt.Printf("ERROR: %v\n", e)
}
if e := c.Wait(); nil != e {
    fmt.Printf("ERROR: %v\n", e)
}
</code></pre>

<p>在运行时打出stacktrace, 再翻翻GO的源代码, 发现GO卡在以下代码</p>

<pre><code>func (c *Cmd) Wait() error {
    ...
    state, err := c.Process.Wait()
    ...
    var copyError error
    for _ = range c.goroutine {
        if err := &lt;-c.errch; err != nil &amp;&amp; copyError == nil {
            copyError = err
        }
    }
    ...
}
</code></pre>

<p>可以看到<code>Wait()</code>在等待Process结束后, 还等待了所有<code>c.goroutine</code>的<code>c.errch</code>信号. 参看以下代码:</p>

<pre><code>func (c *Cmd) stdout() (f *os.File, err error) {
    return c.writerDescriptor(c.Stdout)
}

func (c *Cmd) writerDescriptor(w io.Writer) (f *os.File, err error) {
    ...
    c.goroutine = append(c.goroutine, func() error {
        _, err := io.Copy(w, pr)
        return err
    })
    ...
}
</code></pre>

<p>重定向<code>stdout</code>时, 会添加一个监听任务到<code>goroutine</code> (<code>stderr</code>也是同理)</p>

<p>结论是由于将<code>sleep 100</code>放到后台执行, 其进程<code>stdout</code>并没有关闭, <code>io.Copy()</code>不会返回, 所以会卡住</p>

<p>临时的解决方法就是将后台进程的<code>stdout</code>和<code>stderr</code>重定向出去, 以下代码不会卡住:</p>

<pre><code>c := exec.Command("sh", "-c", "sleep 100 &gt;/dev/null 2&gt;/dev/null &amp;")
var b bytes.Buffer
c.Stdout = &amp;b

if e := c.Start(); nil != e {
    fmt.Printf("ERROR: %v\n", e)
}
if e := c.Wait(); nil != e {
    fmt.Printf("ERROR: %v\n", e)
}
</code></pre>

<p>已经报了<a href="https://code.google.com/p/go/issues/detail?id=7378&amp;thanks=7378&amp;ts=1392967848">bug</a></p>

<p>但想不出好的GO代码的修改方案</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[jruby中tcp阻塞时Timeout::timeout失效]]></title>
    <link href="http://ikarishinjieva.github.com/blog/blog/2014/01/08/jruby-bug-tcp-timeout/"/>
    <updated>2014-01-08T23:04:00+08:00</updated>
    <id>http://ikarishinjieva.github.com/blog/blog/2014/01/08/jruby-bug-tcp-timeout</id>
    <content type="html"><![CDATA[<h3>问题场景</h3>

<p>首先有一台tcp server, 模拟一个黑洞</p>

<p>``` ruby
require 'socket'</p>

<p>tcp_server = TCPServer.new("0.0.0.0", 6666)</p>

<p>loop do</p>

<pre><code> socket = tcp_server.accept
 puts 'got conn']
 #blackhole
</code></pre>

<p>end
```</p>

<p>然后发起一个connection, 从server接受消息(很显然会阻塞在recv上), 并用<code>Timeout::timeout</code>设置一个超时时间</p>

<p>``` ruby
require "socket"
require "timeout"</p>

<p>sock = Socket.new(Socket::AF_INET, Socket::SOCK_STREAM, 0)
addr = Socket.sockaddr_in(6666, "127.0.0.1")
sock.connect(addr)</p>

<p>Timeout::timeout(5) {</p>

<pre><code> sock.recv(1)
</code></pre>

<p>}
```</p>

<p>上面这个场景如果在ruby上跑,5秒后会超时,但如果使用jruby(1.7.6)就会一直处于阻塞</p>

<h3>解决方案</h3>

<p>使用非阻塞<code>recv</code>,可以在jruby上正常运行</p>

<p>``` ruby
require "socket"
require "timeout"</p>

<p>sock = Socket.new(Socket::AF_INET, Socket::SOCK_STREAM, 0)
addr = Socket.sockaddr_in(6666, "127.0.0.1")
sock.connect(addr)</p>

<p>Timeout::timeout(5) {</p>

<pre><code>begin
    sock.recv_nonblock(1)
rescue IO::WaitReadable
    IO.select([sock],nil,nil,5)
    retry
end
</code></pre>

<p>}
```</p>

<h3>猜测</h3>

<p>查看一下ruby <code>timeout.rb</code>的源码</p>

<p>```ruby
  begin</p>

<pre><code>x = Thread.current
y = Thread.start {
  begin
    sleep sec
  rescue =&gt; e
    x.raise e
  else
    x.raise exception, "execution expired"
  end
}
return yield(sec)
</code></pre>

<p>  ensure</p>

<pre><code>if y
  y.kill
  y.join # make sure y is dead.
end
</code></pre>

<p>  end
```</p>

<p>大概看到timeout是起了一个计时线程,超时时向主线程发起exception</p>

<p>猜测是因为jvm的线程模型导致exception不能向阻塞线程提交,但有待验证</p>
]]></content>
  </entry>
  
</feed>
